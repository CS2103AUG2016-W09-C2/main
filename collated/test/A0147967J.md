# A0147967J
###### \java\guitests\AddCommandTest.java
``` java
        //add one non-floating task
        taskToAdd = td.project;
        assertAddNonFloatingSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);
        
        //Unrecognizable recurring type recognized as normaltask
        //duplicate non-floating not allowed
        commandBox.runCommand(td.project.getAddNonFloatingCommand() + "not a type");
        assertResultMessage(AddNonFloatingCommand.MESSAGE_DUPLICATE_TASK);
        assertTrue(taskListPanel.isListMatching(TestUtil.convertTasksToDateComponents(currentList)));
        
        //add deadline task
        taskToAdd = td.paper;
        assertAddNonFloatingSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);
        
        //add task with overlapping slot allowed
        taskToAdd = td.movie;
        assertAddNonFloatingSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);
        
        //add task with illegal time slot
        commandBox.runCommand("add illegal timeslot from 2 oct 2pm to 2 oct 1pm");
        assertResultMessage(AddNonFloatingCommand.MESSAGE_ILLEGAL_TIME_SLOT);
        assertTrue(taskListPanel.isListMatching(TestUtil.convertTasksToDateComponents(currentList)));

        //add to empty list
        commandBox.runCommand("clear");
        assertAddSuccess(td.trash);
        currentList = new TestTask[]{td.trash};

        //invalid command
        commandBox.runCommand("adds Johnny");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
        
        //======Cases for handling recurring tasks==================================================
        
        //Out dated Recurring task got updated
        taskToAdd = td.daily;
        assertAddCommandSuccess("add Daily Task from yesterday 7am to yesterday 8am daily", 
        		taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);
        
        //Up to date remain stayed
        taskToAdd = td.weekly;
        assertAddCommandSuccess(taskToAdd.getAddRecurringCommand(), 
        		taskToAdd, currentList);
        
    }

    private void assertAddSuccess(TestTask taskToAdd, TestTask... currentList) {
    	assertAddCommandSuccess(taskToAdd.getAddFloatingCommand(), taskToAdd, currentList);
    }
    
    private void assertAddNonFloatingSuccess(TestTask taskToAdd, TestTask... currentList) {
        assertAddCommandSuccess(taskToAdd.getAddNonFloatingCommand(), taskToAdd, currentList);
    }
    
    private void assertAddCommandSuccess(String command, TestTask taskToAdd, TestTask... currentList){
    	
    	commandBox.runCommand(command);
        //confirm the new card contains the right data
        TaskCardHandle addedCard = taskListPanel.navigateToTask(taskToAdd.getName().fullName);
        assertMatching(taskToAdd.getTaskDateComponent().get(0), addedCard);

        //confirm the list now contains all previous floatingTasks plus the new floatingTask
        TestTask[] expectedList = TestUtil.addTasksToList(currentList, taskToAdd);
        
        TaskComponent[] taskComponents = TestUtil.convertTasksToDateComponents(expectedList);
        assertTrue(taskListPanel.isListMatching(taskComponents));
    }
}
```
###### \java\guitests\BrowserPanelTest.java
``` java
/**
 * Tests if browser panel can display correct tasks.
 */
public class BrowserPanelTest extends TaskMasterGuiTest{
	
	private final long DAY  = 24*60*60*1000;
	
	@Test
	public void browserPanelTest(){
		
		//Initial case: Out dated tasks/floating/deadlines not displayed, in the list 10 tasks
		assertEquals(0, browser.getMyAgenda().appointments().size());
		
		//Add Non recurring tasks display once
		TestTask toBeAdded = td.none;
		ArrayList<TaskComponent> expectedList = new ArrayList<TaskComponent>();
		expectedList.add(toBeAdded.getLastAppendedComponent());
		commandBox.runCommand(toBeAdded.getAddNonFloatingCommand());
		assertIsAgendaMatching(expectedList);
		
		//Add weekly, monthly or yearly display once
		toBeAdded = td.weekly;
		expectedList.add(toBeAdded.getLastAppendedComponent());
		commandBox.runCommand(toBeAdded.getAddRecurringCommand());
		assertIsAgendaMatching(expectedList);
		
		toBeAdded = td.monthly;
		expectedList.add(toBeAdded.getLastAppendedComponent());
		commandBox.runCommand(toBeAdded.getAddRecurringCommand());
		assertIsAgendaMatching(expectedList);
		
		toBeAdded = td.yearly;
		expectedList.add(toBeAdded.getLastAppendedComponent());
		commandBox.runCommand(toBeAdded.getAddRecurringCommand());
		assertIsAgendaMatching(expectedList);
		
		
		//Add daily tasks, depends on day of week, add copies
		toBeAdded = td.daily;
		expectedList.add(toBeAdded.getLastAppendedComponent());
		expectedList.addAll(getCopies(toBeAdded.getLastAppendedComponent()));
		commandBox.runCommand(toBeAdded.getAddRecurringCommand());
		assertIsAgendaMatching(expectedList);
		
		//Archive current task, style change reflected
		toBeAdded.getLastAppendedComponent().archive();
		TaskComponent toBeArchived = toBeAdded.getLastAppendedComponent();
		expectedList.set(4, toBeArchived);
		commandBox.runCommand("done 15");
		assertIsAgendaMatching(expectedList);
		
		//With block command, style change reflected
		toBeAdded = td.block;
		expectedList.add(toBeAdded.getLastAppendedComponent());
		commandBox.runCommand(toBeAdded.getBlockCommand());
		assertIsAgendaMatching(expectedList);
		
	}	
	
	private ArrayList<TaskComponent> getCopies(TaskComponent t){
		ArrayList<TaskComponent> list = new ArrayList<TaskComponent>();
		int dayOfWeek = TestUtil.getConvertedTime(t.getStartDate()).getDayOfWeek().getValue()%7;
		for(int i = 1; i<=6-dayOfWeek;i++){
			TaskComponent copy = new TaskComponent(t);
			copy.setStartDate(new TaskDate(t.getStartDate().getDateInLong() + DAY*i));
			copy.setEndDate(new TaskDate(t.getEndDate().getDateInLong() + DAY*i));
			list.add(copy);
		}
		return list;
	}
}
```
###### \java\guitests\CompleteCommandTest.java
``` java
/**
 * Tests if the correct task can be marked as done. 
 */
public class CompleteCommandTest extends TaskMasterGuiTest {

    @Test
    public void complete() {

        //delete the first in the list
        TestTask[] currentList = td.getTypicalTasks();
        TestTask[] completed = new TestTask[3];
        int targetIndex = 1;
        completed[0] = currentList[targetIndex-1];
        assertCompleteSuccess(targetIndex, currentList);

        //delete the last in the list
        currentList = TestUtil.removeTaskFromList(currentList, targetIndex);
        targetIndex = currentList.length;
        completed[2] = currentList[targetIndex-1];
        assertCompleteSuccess(targetIndex, currentList);

        //delete from the middle of the list
        currentList = TestUtil.removeTaskFromList(currentList, targetIndex);
        targetIndex = 3;
        completed[1] = currentList[targetIndex-1];
        assertCompleteSuccess(targetIndex, currentList);

        //invalid index
        commandBox.runCommand("done " + currentList.length + 1);
        assertResultMessage("The task index provided is invalid");
        
        //Check changes are reflected in Completed panel
        //Noted that completed tasks are not listed in the deleting order but adding order.
        commandBox.runCommand("find -C");
        assertTrue(taskListPanel.isListMatching(TestUtil.convertTasksToDateComponents(completed)));

    }

    /**
     * Runs the delete command to delete the floatingTask at specified index and confirms the result is correct.
     * @param targetIndexOneIndexed e.g. to delete the first floatingTask in the list, 1 should be given as the target index.
     * @param currentList A copy of the current list of floatingTasks (before deletion).
     */
    private void assertCompleteSuccess(int targetIndexOneIndexed, final TestTask[] currentList) {
        TestTask taskToComplete = currentList[targetIndexOneIndexed-1]; //-1 because array uses zero indexing
        TestTask[] expectedRemainder = TestUtil.removeTaskFromList(currentList, targetIndexOneIndexed);

        commandBox.runCommand("done " + targetIndexOneIndexed);

        //confirm the list now contains all previous floatingTasks except the deleted floatingTask
        assertTrue(taskListPanel.isListMatching(TestUtil.convertTasksToDateComponents(expectedRemainder)));

        //confirm the result message is correct
        assertResultMessage(String.format(MESSAGE_COMPLETE_TASK_SUCCESS, taskToComplete));
    }

}
```
###### \java\guitests\EditCommandTest.java
``` java
public class EditCommandTest extends TaskMasterGuiTest {

    @Test
    public void edit() throws IllegalValueException {
    	
    	//Fix Index first to see edit effect
        //edit deadline
    	int index = 4;
        TestTask[] currentList = td.getTypicalTasks();
        TestTask toBeEdited = currentList[index-1];
        toBeEdited.setEndDate("2 oct 10am");
        currentList[index-1] = toBeEdited;
        assertEditSuccess(toBeEdited, "edit 4 by 2 oct 10am", currentList);
        
        //edit it to time slot
        toBeEdited = currentList[index-1];
        toBeEdited.setEndDate("2 oct 9am");
        toBeEdited.setEndDate("2 oct 11am");
        currentList[index-1] = toBeEdited;
        assertEditSuccess(toBeEdited, "edit 4 from 2 oct 9am to 2 oct 11am", currentList);
        
        //add a tag
        toBeEdited = currentList[index-1];
        toBeEdited.setTag(new UniqueTagList(new Tag("testTag")));
        currentList[index-1] = toBeEdited;
        assertEditSuccess(toBeEdited, "edit 4 t/testTag", currentList);
        
        //add tags
        toBeEdited = currentList[index-1];
        toBeEdited.setTag(new UniqueTagList(new Tag("testTag"),new Tag("testTag1")));
        currentList[index-1] = toBeEdited;
        assertEditSuccess(toBeEdited, "edit 4 t/testTag t/testTag1", currentList);
        
        //change name
        toBeEdited = currentList[index-1];
        toBeEdited.setName(new Name("Test name"));
        currentList[index-1] = toBeEdited;
        assertEditSuccess(toBeEdited, "edit 4 Test name", currentList);
        
        //invalid index
        commandBox.runCommand("edit " + currentList.length + 1 + " invalid index");
        assertResultMessage("The task index provided is invalid");
        
        //invalid command
        commandBox.runCommand("edits read weblecture");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
        
        //Edit a normal task to a recurring task
        toBeEdited = currentList[index - 1];
        toBeEdited.setRecurringType(RecurringType.MONTHLY);
        currentList[index - 1] = toBeEdited;
        assertEditSuccess(toBeEdited, "edit 4 monthly", currentList);
        
        //Edit it back also enabled
        toBeEdited = currentList[index - 1];
        toBeEdited.setRecurringType(RecurringType.NONE);;
        currentList[index - 1] = toBeEdited;
        assertEditSuccess(toBeEdited, "edit 4 none", currentList);

    }
    
    private void assertEditSuccess(TestTask editedCopy, String command, TestTask... modifiedList) {
    	
        commandBox.runCommand(command);
        
        //confirm the new card contains the right data
        TaskCardHandle editedCard = taskListPanel.navigateToTask(editedCopy.getName().fullName);
        assertMatching(editedCopy.getTaskDateComponent().get(0), editedCard);

        //confirm the list now contains all the unmodified tasks and the edited task
        TaskComponent[] taskComponents = TestUtil.convertTasksToDateComponents(modifiedList);
        
        assertTrue(taskListPanel.isListMatching(taskComponents));
    }
    


}
```
###### \java\guitests\FindCommandTest.java
``` java
    @Test
    public void find_byDeadline(){
    	try{
    		//By time-after and sharp
    		assertFindResult("find by 18 oct 5pm", td.labDeadline.getTaskDateComponent().get(0));
    		//By time-before
    		assertFindResult("find by 18 oct 4.59pm");
    	}catch(Exception e){}
    }
    
    @Test
    public void find_byTimeSlot(){
    	//Cover multiple
    	assertFindResult("find from 17 oct 10am to 17 oct 10pm", td.tutorialSlot.getTaskDateComponent().get(0), td.concert.getTaskDateComponent().get(0));
    	//Cover one
    	assertFindResult("find from 17 oct 10am to 17 oct 3pm", td.tutorialSlot.getTaskDateComponent().get(0));
    	//Cover none
    	assertFindResult("find from 17 oct 5pm to 17 oct 6pm");
    }
    
    @Test
    public void find_byTag(){
    	//Existing one tag one result successful
    	assertFindResult("find t/textBook", td.book.getTaskDateComponent().get(0));
    	//Existing multiple tags multiple results successful
    	assertFindResult("find t/CS2105 t/textBook", td.book.getTaskDateComponent().get(0), td.homework.getTaskDateComponent().get(0));
    	//Invalid/Non-existing tag lists nothing
    	assertFindResult("find t/nothing");
    	assertFindResult("find t/--[][]");
    }
    
    @Test
    public void find_byType(){
    	//Floating tasks
    	assertFindResult("find -F",td.trash.getTaskDateComponent().get(0), td.book.getTaskDateComponent().get(0), 
    	        td.homework.getTaskDateComponent().get(0), td.lecture.getTaskDateComponent().get(0), 
    	        td.meeting.getTaskDateComponent().get(0), td.george.getTaskDateComponent().get(0));
    	//Completed tasks
    	commandBox.runCommand("done 1");
    	assertFindResult("find -C", td.trash.getTaskDateComponent().get(0));    	
    }
```
###### \java\guitests\guihandles\BrowserPanelHandle.java
``` java
/**
 * Provides a handle for the panel containing the task list.
 */
public class BrowserPanelHandle extends GuiHandle {

    public static final int NOT_FOUND = -1;

    private static final String AGENDA_ID = "#agenda";

    public BrowserPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    public MyAgenda getMyAgenda() {
        return (MyAgenda) getNode(AGENDA_ID);
    }
    
    public boolean isContained(AppointmentImplLocal target){
    	for(Appointment a: getMyAgenda().appointments())
    		if(TestUtil.isSameAppointment(a, target)) return true;
    	return false;
    }

}
```
###### \java\guitests\guihandles\NavbarPanelHandle.java
``` java
/**
 * Provides a handle for the panel containing the task list.
 */
public class NavbarPanelHandle extends GuiHandle {
	
	private final String NAVBAR_TASKS = " Tasks";
    private final String NAVBAR_DEADLINES = " Deadlines";
    private final String NAVBAR_INCOMING_DEADLINES = " Incoming Deadlines";
    private final String NAVBAR_FLOATING_TASKS = " Floating Tasks";
    private final String NAVBAR_COMPLETED = " Completed";
    
    private final ObservableList<String> navbarElement = FXCollections.observableArrayList(NAVBAR_TASKS, NAVBAR_DEADLINES, NAVBAR_FLOATING_TASKS
			  																					 ,NAVBAR_INCOMING_DEADLINES, NAVBAR_COMPLETED);

    public static final int NOT_FOUND = -1;
    public static final String CARD_PANE_ID = "#cardPaneNav";

    private static final String TASK_LIST_VIEW_ID = "#navbarView";

    public NavbarPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    public List<String> getSelectedNavigation() {
        ListView<String> navigationList = getListView();
        return navigationList.getSelectionModel().getSelectedItems();
    }

    @SuppressWarnings("unchecked")
	public ListView<String> getListView() {
        return (ListView<String>) getNode(TASK_LIST_VIEW_ID);
    }

    /**
     * Navigates the list view to display and select the task.
     */
    public void navigateTo(String nav) {
        int index = navbarElement.indexOf(nav);

        guiRobot.interact(() -> {
            getListView().scrollTo(index);
            guiRobot.sleep(150);
            getListView().getSelectionModel().select(index);
        });
        guiRobot.sleep(550);
        
    }
}
```
###### \java\guitests\NavbarPanelTest.java
``` java
public class NavbarPanelTest extends TaskMasterGuiTest {
	
	private final String NAVBAR_TASKS = " Tasks";
    private final String NAVBAR_DEADLINES = " Deadlines";
    private final String NAVBAR_INCOMING_DEADLINES = " Incoming Deadlines";
    private final String NAVBAR_FLOATING_TASKS = " Floating Tasks";
    private final String NAVBAR_COMPLETED = " Completed";
    	
	@Test
	public void navigateToFloatingTasks() {
		TaskComponent[] expected;
		//Navigate to all floating tasks
		expected = Arrays.copyOfRange(td.getTypicalTaskComponents(), 0, 6);
		assertResult(NAVBAR_FLOATING_TASKS, expected);
	}
	
	@Test
	public void navigateToDeadlines() {
		//Navigate to deadlines
		assertResult(NAVBAR_DEADLINES, td.labDeadline.getComponentForNonRecurringType(),
												td.essayDeadline.getComponentForNonRecurringType());
	}
	
	@Test
	public void navigateToIncomingDeadlines() {
		//Navigate to incoming deadlines
		commandBox.runCommand(td.incoming.getAddNonFloatingCommand());
		assertResult(NAVBAR_INCOMING_DEADLINES, td.labDeadline.getComponentForNonRecurringType(),
												td.essayDeadline.getComponentForNonRecurringType(),
												td.incoming.getComponentForNonRecurringType());
	}
	
	@Test
	public void navigateToAllTasks() {
		//Navigate to all tasks
		TaskComponent[] expected = td.getTypicalTaskComponents();
		assertResult(NAVBAR_TASKS, expected);
	}
	
	@Test
	public void navigateToCompletedOnes() {
		//Navigate to completed ones
		commandBox.runCommand("done 1");
		assertResult(NAVBAR_COMPLETED, td.trash.getComponentForNonRecurringType());
	}
		
	private void assertResult(String navigation, TaskComponent... expectedHits) {
        navbar.navigateTo(navigation);
        assertListSize(expectedHits.length);
        if(navigation.equals(NAVBAR_TASKS))
        	assertResultMessage("Listed all tasks");
        else
        	assertResultMessage(expectedHits.length + " tasks listed!");
        assertTrue(taskListPanel.isListMatching(expectedHits));
    }

}
```
###### \java\guitests\TaskMasterGuiTest.java
``` java
    /**
     * Asserts the expected task components are reflected in the agenda.
     * @param expected
     */
    protected void assertIsAgendaMatching(ArrayList<TaskComponent> expectedShown){
		//Get the updated agenda
		MyAgenda toBeChecked = browser.getMyAgenda();
		//Checks the number of items in the agenda
		assertEquals(expectedShown.size(), toBeChecked.appointments().size());
		//Checks one-to-one match
		for(TaskComponent t: expectedShown){
			assertTrue(browser.isContained(TestUtil.getAppointment(t)));
		}
	}

}
```
###### \java\guitests\ViewCommandTest.java
``` java
/**
 * Tests view command and agenda time range change event.
 * Currently only tentative and will add in more later. 
 */
public class ViewCommandTest extends TaskMasterGuiTest{
	
	private final long DAY  = 24*60*60*1000;
	@Test
	public void view(){
		
		//View today
		TestTask toBeAdded = td.weekly;
		ArrayList<TaskComponent> expectedList = new ArrayList<TaskComponent>();
		expectedList.add(toBeAdded.getLastAppendedComponent());
		commandBox.runCommand(toBeAdded.getAddRecurringCommand());
		assertViewSuccess("today", expectedList);
		
		//View next week today
		TaskComponent updated = toBeAdded.getLastAppendedComponent();
		updated.setStartDate(new TaskDate(updated.getStartDate().getDateInLong() + 7 * DAY));
		updated.setEndDate(new TaskDate(updated.getEndDate().getDateInLong() + 7 * DAY));
		expectedList.set(0, updated);
		assertViewSuccess("next week today", expectedList);
	}
	
	public void assertViewSuccess(String date, ArrayList<TaskComponent> expectedList){
		
		commandBox.runCommand("view "+date);
		assertEquals(TestUtil.getConvertedTime(new TaskDate(date)).truncatedTo(ChronoUnit.DAYS),
				browser.getMyAgenda().getDisplayedLocalDateTime());
		assertIsAgendaMatching(expectedList);
		
	}
}
```
###### \java\seedu\address\logic\LogicManagerTest.java
``` java
    @Test
    public void execute_addNonFloating_sucessful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.nonFloatingFromDateToDate();
        TaskMaster expectedAB = new TaskMaster();
        expectedAB.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toBeAdded),
                expectedAB,
                expectedAB.getTaskComponentList());
        assertUndoRedoAble(String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toBeAdded),
                expectedAB,
                expectedAB.getTaskComponentList());
    }
```
###### \java\seedu\address\logic\LogicManagerTest.java
``` java
    @Test
    public void execute_addDuplicate_notAllowed() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.adam();
        TaskMaster expectedAB = new TaskMaster();
        expectedAB.addTask(toBeAdded);
        
        // setup starting state
        model.addTask(toBeAdded); // task already in internal task list
       
        // execute command and verify result
        assertCommandBehavior(
                helper.generateAddCommand(toBeAdded),
                AddFloatingCommand.MESSAGE_DUPLICATE_TASK,
                expectedAB,
                expectedAB.getTaskComponentList());
    }
    
     
    @Test
    public void execute_addOverlapSlot_allowed() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = new Task(new Name("Task one"), new UniqueTagList(),
        						  new TaskDate("2 oct 2am"), new TaskDate("2 oct 1pm"), 
        						  RecurringType.NONE);
        Task toBeAddedAfter = new Task(new Name("Task two"), new UniqueTagList(),
				  new TaskDate("2 oct 10am"), new TaskDate("2 oct 11am"), 
				  RecurringType.NONE);
        TaskMaster expectedAB = new TaskMaster();
        expectedAB.addTask(toBeAdded);
        expectedAB.addTask(toBeAddedAfter);

        // setup starting state
        model.addTask(toBeAdded); // task already in internal task list

        // execute command and verify result
        assertCommandBehavior(
                helper.generateAddCommand(toBeAddedAfter),
                String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toBeAddedAfter),
                expectedAB,
                expectedAB.getTaskComponentList());

    }
    
    @Test
    public void execute_addDeadlineOverlap_Successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = new Task(new Name("Task one"), new UniqueTagList(),
        						  new TaskDate("2 oct 2am"), new TaskDate("2 oct 1pm"),
        						  RecurringType.NONE);
        Task toBeAddedAfter = new Task(new Name("Task two"), new UniqueTagList(),
				  new TaskDate(TaskDate.DATE_NOT_PRESENT), new TaskDate("2 oct 11am"),
				  RecurringType.NONE);
        TaskMaster expectedAB = new TaskMaster();
        expectedAB.addTask(toBeAdded);
        expectedAB.addTask(toBeAddedAfter);

        // setup starting state
        model.addTask(toBeAdded); // task already in internal task list

        // execute command and verify result
        assertCommandBehavior(
                helper.generateAddCommand(toBeAddedAfter),
                String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toBeAddedAfter),
                expectedAB,
                expectedAB.getTaskComponentList());
        assertUndoRedoAble(String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toBeAddedAfter),
                expectedAB,
                expectedAB.getTaskComponentList());

    }
    
    @Test
    public void execute_addIllegalSlot_notAllowed() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = new Task(new Name("Task one"), new UniqueTagList(),
        						  new TaskDate("2 oct 6am"), new TaskDate("2 oct 5am"),
        						  RecurringType.NONE);
        TaskMaster expectedAB = new TaskMaster();

        // execute command and verify result
        assertCommandBehavior(
                helper.generateAddCommand(toBeAdded),
                AddNonFloatingCommand.MESSAGE_ILLEGAL_TIME_SLOT,
                expectedAB,
                expectedAB.getTaskComponentList());

    }
```
###### \java\seedu\address\logic\LogicManagerTest.java
``` java
    /**
     * The logic for block command is actually the same as add-non=floating commands.
     * */   
    @Test
    public void execute_block_invalidArgsFormat() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, BlockCommand.MESSAGE_USAGE);
        assertCommandBehavior(
                "block 2am to 3am", expectedMessage);
    }
    
    @Test
    public void execute_block_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = new Task(new Name(BlockCommand.DUMMY_NAME), new UniqueTagList(),
				  new TaskDate("2 oct 2am"), new TaskDate("2 oct 1pm"), 
				  RecurringType.NONE);
        TaskMaster expectedAB = new TaskMaster();
        expectedAB.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateBlockCommand(toBeAdded),
                String.format(BlockCommand.MESSAGE_SUCCESS, toBeAdded),
                expectedAB,
                expectedAB.getTaskComponentList());
        assertUndoRedoAble(String.format(BlockCommand.MESSAGE_SUCCESS, toBeAdded),
                expectedAB,
                expectedAB.getTaskComponentList());

    }
    
    @Test
    public void execute_blockOverlapSlot_notAllowed() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeBlocked = new Task(new Name(BlockCommand.DUMMY_NAME), new UniqueTagList(),
        						  new TaskDate("2 oct 2am"), new TaskDate("2 oct 1pm"), 
        						  RecurringType.NONE);
        Task toBeAddedAfter = new Task(new Name(BlockCommand.DUMMY_NAME), new UniqueTagList(),
				  new TaskDate("2 oct 10am"), new TaskDate("2 oct 11am"),
				  RecurringType.NONE);
        TaskMaster expectedAB = new TaskMaster();
        expectedAB.addTask(toBeBlocked);

        // setup starting state
        model.addTask(toBeBlocked); // task already in internal task list

        // execute command and verify result
        assertCommandBehavior(
                helper.generateAddCommand(toBeAddedAfter),
                BlockCommand.MESSAGE_TIMESLOT_OCCUPIED,
                expectedAB,
                expectedAB.getTaskComponentList());

    }
    
    @Test
    public void execute_blockOverlapWithExistingTask_notAllowed() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeBlocked = new Task(new Name("Test Task"), new UniqueTagList(),
        						  new TaskDate("2 oct 2am"), new TaskDate("2 oct 1pm"), 
        						  RecurringType.NONE);
        Task toBeAddedAfter = new Task(new Name(BlockCommand.DUMMY_NAME), new UniqueTagList(),
				  new TaskDate("2 oct 10am"), new TaskDate("2 oct 11am"),
				  RecurringType.NONE);
        TaskMaster expectedAB = new TaskMaster();
        expectedAB.addTask(toBeBlocked);

        // setup starting state
        model.addTask(toBeBlocked); // task already in internal task list

        // execute command and verify result
        assertCommandBehavior(
                helper.generateAddCommand(toBeAddedAfter),
                BlockCommand.MESSAGE_TIMESLOT_OCCUPIED,
                expectedAB,
                expectedAB.getTaskComponentList());

    }
    
    @Test
    public void execute_blockIllegalSlot_notAllowed() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeBlocked = new Task(new Name(BlockCommand.DUMMY_NAME), new UniqueTagList(),
        						  new TaskDate("2 oct 6am"), new TaskDate("2 oct 5am"),
        						  RecurringType.NONE);
        TaskMaster expectedAB = new TaskMaster();

        // execute command and verify result
        assertCommandBehavior(
                helper.generateBlockCommand(toBeBlocked),
                BlockCommand.MESSAGE_ILLEGAL_TIME_SLOT,
                expectedAB,
                expectedAB.getTaskComponentList());

    }
    
    /**
     * Tests for undo/redo commands.
     */   
    @Test
    public void execute_undoredoNothing_notAllowed() throws Exception {
    	// setup expectations
        TaskMaster expectedAB = new TaskMaster();

        // execute command and verify result
        assertCommandBehavior(
                "u",
                UndoCommand.MESSAGE_FAIL,
                expectedAB,
                expectedAB.getTaskComponentList());
        
        assertCommandBehavior(
                "r",
                RedoCommand.MESSAGE_FAIL,
                expectedAB,
                expectedAB.getTaskComponentList());
    }
    
      
    @Test
    public void execute_undoredo_Successful() throws Exception {
    	// setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.adam();
        TaskMaster expectedAB = new TaskMaster();
        expectedAB.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddFloatingCommand.MESSAGE_SUCCESS, toBeAdded),
                expectedAB,
                expectedAB.getTaskComponentList());
        
        expectedAB = new TaskMaster();
        assertCommandBehavior("u",
                UndoCommand.MESSAGE_SUCCESS,
                expectedAB,
                expectedAB.getTaskComponentList());
        
        expectedAB.addTask(toBeAdded);
        assertCommandBehavior(
                "r",
                String.format(AddFloatingCommand.MESSAGE_SUCCESS, toBeAdded),
                expectedAB,
                expectedAB.getTaskComponentList());        
    }
    
    @Test
    public void execute_undoredoReachMaxTimes_notAllowed() throws Exception{
    	TestDataHelper helper = new TestDataHelper();
    	TaskMaster expectedAB = new TaskMaster();
    	for(int i = 1; i < 5; i++){
    		Task t = helper.generateTask(i);
    		logic.execute(helper.generateAddCommand(t));
    	}
    	for(int i = 0; i < 3; i++)
    		logic.execute("u");
    	
    	expectedAB.addTask(helper.generateTask(1));
    	assertCommandBehavior(
                "u",
                UndoCommand.MESSAGE_FAIL,
                expectedAB,
                expectedAB.getTaskComponentList());
    	
    	for(int i = 0; i < 3; i++){
    		logic.execute("r");
    		expectedAB.addTask(helper.generateTask(2+i));
    	}
    	
    	assertCommandBehavior(
                "r",
                RedoCommand.MESSAGE_FAIL,
                expectedAB,
                expectedAB.getTaskComponentList());
    }
    
    @Test
    public void execute_undoInvalidCommand_notAllowed() throws Exception{
    	
    	TaskMaster expectedAB = new TaskMaster();
    	logic.execute("adds t");
    	assertCommandBehavior(
                "u",
                UndoCommand.MESSAGE_FAIL,
                expectedAB,
                expectedAB.getTaskComponentList());
    	
    }
    
    @Test
    public void execute_undoFailedCommand_notAllowed() throws Exception{
    	
    	TestDataHelper helper = new TestDataHelper();
    	TaskMaster expectedAB = new TaskMaster();
    	Task toBeAdded = helper.adam();
    	
    	expectedAB.addTask(toBeAdded);
    	model.addTask(toBeAdded);
    	
    	logic.execute(helper.generateAddCommand(toBeAdded));
    	
    	assertCommandBehavior(
                "u",
                UndoCommand.MESSAGE_FAIL,
                expectedAB,
                expectedAB.getTaskComponentList());
    	
    }
    
    
    /***
     * Tests for ChangeDirectoryCommand
     */
    @Test
    public void execute_changeDirectoryIllegalDirectory_notAllowed() throws Exception{
    	
    	TaskMaster expectedAB = new TaskMaster();
    	assertCommandBehavior(
    			"cd random path",
                ChangeDirectoryCommand.MESSAGE_CONVENSION_ERROR,
                expectedAB,
                expectedAB.getTaskComponentList());
    }
    
    @Test
    public void execute_changeDirectoryWrongFileType_notAllowed() throws Exception{
    	
    	TaskMaster expectedAB = new TaskMaster();
    	assertCommandBehavior(
    			"cd "+saveFolder.getRoot().getPath()+"cdtest.txt",
                ChangeDirectoryCommand.MESSAGE_CONVENSION_ERROR,
                expectedAB,
                expectedAB.getTaskComponentList());
    }
    
    @Test
    public void execute_changeDirectory_Successful() throws Exception{
    	
    	TestDataHelper helper = new TestDataHelper();
    	TaskMaster expectedAB = new TaskMaster();
    	assertCommandBehavior(
    			"cd "+ saveFolder.getRoot().getPath()+"cdtest.xml",
    			String.format(ChangeDirectoryCommand.MESSAGE_SUCCESS, saveFolder.getRoot().getPath()+"cdtest.xml"),
                expectedAB,
                expectedAB.getTaskComponentList());
    	
    	//Ensure model writes to this file
    	expectedAB.addTask(helper.adam());
    	logic.execute(helper.generateAddCommand(helper.adam()));
        ReadOnlyTaskMaster retrieved = new StorageManager(saveFolder.getRoot().getPath()+"cdtest.xml", 
        		                                        saveFolder.getRoot().getPath() + "TempPreferences.json").readTaskList().get();
        assertEquals(expectedAB, new TaskMaster(retrieved));
        assertEquals(model.getTaskMaster(), new TaskMaster(retrieved));
        
    }
```
###### \java\seedu\address\logic\LogicManagerTest.java
``` java
    @Test
    public void execute_completeInvalidArgsFormat_errorMessageShown() throws Exception {
    	String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE);
    	assertIncorrectIndexFormatBehaviorForCommand("done", expectedMessage);
    }
    
    @Test
    public void execute_completeIndexNotFound_errorMessageShown() throws Exception {
    	assertIndexNotFoundBehaviorForCommand("done");
    }
    
    @Test
    public void execute_complete_removesCorrectTask() throws Exception {
        TestDataHelper helper = new TestDataHelper();

        Task toComplete = helper.adam();
        TaskMaster expectedAB = new TaskMaster();
        expectedAB.addTask(toComplete);
        model.addTask(toComplete);

        assertCommandBehavior("done 1", 
        		String.format(CompleteCommand.MESSAGE_COMPLETE_TASK_SUCCESS, toComplete),
        	    expectedAB,
        	    new TaskMaster().getTaskComponentList());
        assertUndoRedoAble(String.format(CompleteCommand.MESSAGE_COMPLETE_TASK_SUCCESS, toComplete),
        	    expectedAB,
        	    new TaskMaster().getTaskComponentList());

    }
```
###### \java\seedu\address\logic\LogicManagerTest.java
``` java
    @Test
    public void execute_findByDateTimeBoundary() throws Exception{
    	TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateTaskWithName("bla bla KEY bla");
        Task pTarget2 = helper.generateTaskWithName("bla rAnDoM bla bceofeia");
        Task pTarget3 = helper.generateTaskWithName("key key");
        Task p1 = helper.generateTaskWithName("sduauo");
        Task test = helper.nonFloatingByDate();
        Task test2 = helper.nonFloatingFromDateToDate();

        List<Task> fourTasks = helper.generateTasks(pTarget1, p1, pTarget2, pTarget3);
        TaskMaster expectedAB = helper.generateTaskList(fourTasks);
        List<Task> expectedList = helper.generateTasks(test);
        
        expectedAB.addTask(test);
        expectedAB.addTask(test2);
        helper.addToModel(model, fourTasks);
        model.addTask(test);
        model.addTask(test2);
        
        List<TaskComponent> componentList = helper.buildTaskComponentsFromTaskList(expectedList);
        
        //find by exact time successful
        assertCommandBehavior("find by 20 oct 11am",
                Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedAB,
                componentList);
        //find by earlier time boundary lists nothing
        assertCommandBehavior("find by 20 oct 10.59am",
                Command.getMessageForTaskListShownSummary(0),
                expectedAB,
                new TaskMaster().getTaskComponentList());
        //find by later time boundary successful
        assertCommandBehavior("find by 20 oct 11.01pm",
                Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedAB,
                componentList);
    }
    
    @Test
    public void execute_findFromDateBoundaryToDateBoundary() throws Exception{
    	TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateTaskWithName("bla bla KEY bla");
        Task pTarget2 = helper.generateTaskWithName("bla rAnDoM bla bceofeia");
        Task pTarget3 = helper.generateTaskWithName("key key");
        Task p1 = helper.generateTaskWithName("sduauo");
        Task test = helper.nonFloatingFromDateToDate();
        Task test2 = helper.nonFloatingByDate();

        List<Task> fourTasks = helper.generateTasks(pTarget1, p1, pTarget2, pTarget3);
        TaskMaster expectedAB = helper.generateTaskList(fourTasks);
        List<Task> expectedList = helper.generateTasks(test);
        
        expectedAB.addTask(test);
        expectedAB.addTask(test2);

        helper.addToModel(model, fourTasks);
        model.addTask(test);
        model.addTask(test2);
        List<TaskComponent> expectedComponentList = helper.buildTaskComponentsFromTaskList(expectedList);
        
        //find by exact boundary successful
        assertCommandBehavior("find from 19 oct 10pm to 20 oct 11am",
                Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedAB,
                expectedComponentList);
        //find by smaller boundary lists nothing
        assertCommandBehavior("find from 19 oct 10.01pm to 20 oct 11am",
                Command.getMessageForTaskListShownSummary(0),
                expectedAB,
                new TaskMaster().getTaskComponentList());
        
        assertCommandBehavior("find from 19 oct 10pm to 20 oct 10.59am",
                Command.getMessageForTaskListShownSummary(0),
                expectedAB,
                new TaskMaster().getTaskComponentList());
        //find by lax boundary successful
        assertCommandBehavior("find from 19 oct 9pm to 20 oct 1pm",
                Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedAB,
                expectedComponentList);
    }
    
    @Test
    public void execute_findFloatingTasksbyType_Successful() throws Exception{
    	TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateTaskWithName("bla bla KEY bla");
        Task pTarget2 = helper.generateTaskWithName("bla rAnDoM bla bceofeia");
        Task pTarget3 = helper.generateTaskWithName("key key");
        Task p1 = helper.generateTaskWithName("sduauo");
        Task test = helper.nonFloatingFromDateToDate();

        List<Task> threeTasks = helper.generateTasks(pTarget1, pTarget2, pTarget3);
        TaskMaster expectedAB = helper.generateTaskList(threeTasks);
        List<Task> expectedList = helper.generateTasks(pTarget1, pTarget2, pTarget3);
        
        expectedAB.addTask(test);
        expectedAB.addTask(p1);

        helper.addToModel(model, threeTasks);
        model.addTask(test);
        model.addTask(p1);
        logic.execute("done 5");
        
        List<TaskComponent> expectedComponentList = helper.buildTaskComponentsFromTaskList(expectedList);

        assertCommandBehavior("find -F",
                Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedAB,
                expectedComponentList);
        
    }
    
    @Test
    public void execute_findCompletedTasksbyType_Successful() throws Exception{
    	TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateTaskWithName("bla bla KEY bla");
        Task test = helper.nonFloatingFromDateToDate();

        TaskMaster expectedAB = new TaskMaster();
        List<Task> expectedList = helper.generateTasks(test);
        
        expectedAB.addTask(pTarget1);
        expectedAB.addTask(test);

        model.addTask(pTarget1);
        model.addTask(test);
        
        List<TaskComponent> expectedComponentList = helper.buildTaskComponentsFromTaskList(expectedList);
        
        logic.execute("done 2");
        
        assertCommandBehavior("find -C",
                Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedAB,
                expectedComponentList);
        
    }
    @Test
    public void execute_findbyMultipleConstraints_Successful() throws Exception{
    	TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateTaskWithName("bla bla KEY bla");
        Task test = helper.nonFloatingFromDateToDate();

        TaskMaster expectedAB = new TaskMaster();
        List<Task> expectedList = helper.generateTasks(test);
        
        expectedAB.addTask(pTarget1);
        expectedAB.addTask(test);

        model.addTask(pTarget1);
        model.addTask(test);
        
        List<TaskComponent> expectedComponentList = helper.buildTaskComponentsFromTaskList(expectedList);
        
        assertCommandBehavior("find non floating from 19 oct 1am to 21 oct 3am",
                Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedAB,
                expectedComponentList);
        
    }
    
    
    @Test
    public void execute_findbyTag_Successful() throws Exception {
    	TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateTaskWithName("bla bla KEY bla");
        Task test = helper.nonFloatingFromDateToDate();

        TaskMaster expectedAB = new TaskMaster();
        List<Task> expectedList = helper.generateTasks(test);
        
        expectedAB.addTask(pTarget1);
        expectedAB.addTask(test);

        model.addTask(pTarget1);
        model.addTask(test);
        
        List<TaskComponent> expectedComponentList = helper.buildTaskComponentsFromTaskList(expectedList);
        
        assertCommandBehavior("find t/tag1",
                Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedAB,
                expectedComponentList);
        
    }
    
    /**
     * Tests for view command. 
     */
    @Test
    public void execute_view_InvalidInputDate_notAllowed() throws Exception{
    	String expectedMessage = Messages.MESSAGE_ILLEGAL_DATE_INPUT;
    	assertCommandBehavior("view random input", expectedMessage);
    }
    
    @Test
    public void execute_view_successful() throws Exception {
    	String test = "23 oct 12am";
    	TaskDate testDate = new TaskDate(test);
    	assertCommandBehavior("view 23 oct 12am",
    			String.format(ViewCommand.MESSAGE_UPDATE_AGENDA_SUCCESS, formatter.format(testDate.getDate())));
    	assertEquals(testDate, checkDate);
    	assertEquals(latestSavedTaskList.getTaskComponentList(), checkList);
    	assertEquals(model.getTaskMaster().getTaskComponentList(), checkList);
    }
```
###### \java\seedu\address\testutil\TestUtil.java
``` java
    /** Returns a LocalDateTime object converted from TaskDate. */
	public static LocalDateTime getConvertedTime(TaskDate t){
		return LocalDateTime.ofInstant(new Date(t.getDateInLong()).toInstant(), ZoneId.systemDefault());    	
    }
	
	/** Returns an AppointmentImplLocal object from a task component */
	public static AppointmentImplLocal getAppointment(TaskComponent taskComponent){
		
		AppointmentImplLocal appointment = new AppointmentImplLocal();
		appointment.setSummary(taskComponent.getTaskReference().getName().fullName);
		appointment.setDescription(taskComponent.getTaskReference().tagsString());
		appointment.setStartLocalDateTime(getConvertedTime(taskComponent.getStartDate()));			
		appointment.setEndLocalDateTime(getConvertedTime(taskComponent.getEndDate()));
		if(taskComponent.isArchived()){
			appointment.setAppointmentGroup(new Agenda.AppointmentGroupImpl().withStyleClass("archive"));			
		}else if(taskComponent.getTaskReference().getName().fullName.equals(BlockCommand.DUMMY_NAME)){
			appointment.setAppointmentGroup(new Agenda.AppointmentGroupImpl().withStyleClass("block"));
		}else{
			appointment.setAppointmentGroup(new Agenda.AppointmentGroupImpl().withStyleClass("normal"));
		}	
		return appointment;
			
	}
	
	public static boolean isSameAppointment(Appointment a, AppointmentImplLocal a2){
		return a.getAppointmentGroup().getStyleClass().equals(a2.getAppointmentGroup().getStyleClass()) 
				&& a.getStartLocalDateTime().equals(a2.getStartLocalDateTime())
				&& a.getEndLocalDateTime().equals(a2.getEndLocalDateTime())
				&& a.getDescription().equals(a2.getDescription())
				&& a.getSummary().equals(a2.getSummary());
	}

}
```
