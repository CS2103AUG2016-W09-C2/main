# A0135782Y
###### \java\seedu\address\logic\LogicManagerTest.java
``` java
    @Test
    public void execute_add_successful_non_floating_from_date_to_date() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.nonFloatingFromDateToDate();
        TaskMaster expectedTM = new TaskMaster();
        expectedTM.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toBeAdded), expectedTM,
                expectedTM.getTaskOccurrenceList());
        assertUndoRedoAble(String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toBeAdded), expectedTM,
                expectedTM.getTaskOccurrenceList());
    }

    @Test
    public void execute_add_successful_non_floating_by_date() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.nonFloatingByDate();
        TaskMaster expectedTM = new TaskMaster();
        expectedTM.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toBeAdded), expectedTM,
                expectedTM.getTaskOccurrenceList());
        assertUndoRedoAble(String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toBeAdded), expectedTM,
                expectedTM.getTaskOccurrenceList());
    }

```
###### \java\seedu\address\logic\LogicManagerTest.java
``` java
    @Test
    public void execute_addRecurringTaskByDate_unsuccessful() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        TaskMaster expectedTM = new TaskMaster();
        Task toAdd = helper.nonFloatingByDate();
        expectedTM.addTask(toAdd);
        List<TaskOccurrence> expectedComponentList = helper.buildTaskComponentsFromTaskList(expectedTM.getTasks());
        assertCommandBehavior("add non floating task by XXXX by 20 oct 11am dai t/tag1 t/tag2",
                String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toAdd), expectedTM, expectedComponentList);
    }

    @Test
    public void execute_addRecurringTaskByDate_successful() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        TaskMaster expectedTM = new TaskMaster();
        Task toAdd = helper.nonFloatingRecurringByDate(RecurringType.DAILY);
        expectedTM.addTask(toAdd);
        RecurringTaskManager.getInstance().correctOverdueNonRepeatingTasks(toAdd);
        List<TaskOccurrence> expectedComponentList = helper.buildTaskComponentsFromTaskList(expectedTM.getTasks());
        assertCommandBehavior("add non floating task by XXXX by 20 oct 11am daily t/tag1 t/tag2",
                String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toAdd), expectedTM, expectedComponentList);
    }

    @Test
    public void execute_add_recurringTaskByDateDaily_caseInsensitive() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        TaskMaster expectedTM = new TaskMaster();
        Task toAdd = helper.nonFloatingRecurringByDate(RecurringType.DAILY);
        expectedTM.addTask(toAdd);
        RecurringTaskManager.getInstance().correctOverdueNonRepeatingTasks(toAdd);
        List<TaskOccurrence> expectedComponentList = helper.buildTaskComponentsFromTaskList(expectedTM.getTasks());
        assertCommandBehavior("add non floating task by XXXX by 20 oct 11am dAIly t/tag1 t/tag2",
                String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toAdd), expectedTM, expectedComponentList);
    }

    @Test
    public void execute_addRecurringTaskFromDateToDate_unsuccessful() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        TaskMaster expectedTM = new TaskMaster();
        Task toAdd = helper.nonFloatingFromDateToDate();
        expectedTM.addTask(toAdd);
        RecurringTaskManager.getInstance().correctOverdueNonRepeatingTasks(toAdd);
        List<TaskOccurrence> expectedComponentList = helper.buildTaskComponentsFromTaskList(expectedTM.getTasks());
        assertCommandBehavior(
                "add non floating task from XXXX to XXXX from 19 oct 10pm to 20 oct 11am dai t/tag1 t/tag2",
                String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toAdd), expectedTM, expectedComponentList);
    }

    @Test
    public void execute_addRecurringTaskFromDateToDate_successful() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        TaskMaster expectedTM = new TaskMaster();
        Task toAdd = helper.nonFloatingRecurringFromDateToDate(RecurringType.DAILY);
        expectedTM.addTask(toAdd);
        RecurringTaskManager.getInstance().correctOverdueNonRepeatingTasks(toAdd);
        List<TaskOccurrence> expectedComponentList = helper.buildTaskComponentsFromTaskList(expectedTM.getTasks());
        assertCommandBehavior(
                "add non floating task from XXXX to XXXX from 19 oct 10pm to 20 oct 11am daily t/tag1 t/tag2",
                String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toAdd), expectedTM, expectedComponentList);
    }

    @Test
    public void execute_add_recurringTaskDailyFromDateToDate_caseInsensitive() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        TaskMaster expectedTM = new TaskMaster();
        Task toAdd = helper.nonFloatingRecurringFromDateToDate(RecurringType.DAILY);
        expectedTM.addTask(toAdd);
        RecurringTaskManager.getInstance().correctOverdueNonRepeatingTasks(toAdd);
        List<TaskOccurrence> expectedComponentList = helper.buildTaskComponentsFromTaskList(expectedTM.getTasks());
        assertCommandBehavior(
                "add non floating task from XXXX to XXXX from 19 oct 10pm to 20 oct 11am dAIly t/tag1 t/tag2",
                String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toAdd), expectedTM, expectedComponentList);
    }
```
###### \java\seedu\address\model\RecurringTaskManagerTest.java
``` java
public class RecurringTaskManagerTest {
    private RecurringTaskManager recurringManager;
    private RecurringTaskHelper helper;
    private TaskMaster taskMaster;
    private Model model;
    
    @Before
    public void setUp() {
        recurringManager = RecurringTaskManager.getInstance();
        helper = new RecurringTaskHelper();
        model = new ModelManager();
        taskMaster = (TaskMaster) model.getTaskMaster();
        recurringManager.setTaskList(taskMaster.getUniqueTaskList());
    }
    
    @Test(expected = AssertionError.class)
    public void setTasklist_nullTaskList_throwAssert() {
        recurringManager.setTaskList(null);
    }
    
    @Test
    public void setTaskList_successful() {
        recurringManager.setTaskList(taskMaster.getUniqueTaskList());
        UniqueTaskList toCompare = recurringManager.getTaskList();
        assertEquals(toCompare, taskMaster.getUniqueTaskList());
    }    
    
    @Test(expected = AssertionError.class)
    public void correctAddingOverdueTasks_nullTaskList_throwAssert() {
        recurringManager.correctOverdueNonRepeatingTasks(null);
    }
    
    @Test
    public void updateRecurringTask_successful() throws Exception {
        TestTask testData = helper.buildRecurringTask(RecurringType.DAILY);
        Task tryUpdate = new Task(testData);
        taskMaster.addTask(tryUpdate);
        recurringManager.appendAnyRecurringTasks(helper.getLocalDateByString("2016-10-12"));
        
        assertEquals("Recurring task should be updated to append 1 more task occurrence", taskMaster.getTaskOccurrenceList().size(), 2);
        assertEquals("Recurring task should be have unique tasks", taskMaster.getTaskList().size(), 1);
    }
    
    @Test
    public void correctAssingOverdueTasks_nonRecurringTask() throws Exception {
        TestTask tryCorrect = helper.buildNonRecurringTask_withStartDate();
        TestTask expectedTask = helper.buildNonRecurringTask_withStartDate();
        recurringManager.setTestMode(false);
        recurringManager.correctOverdueNonRepeatingTasks(tryCorrect);
        assertEquals("Non recurring tasks should not be corrected", tryCorrect, expectedTask);
    }
    
    @Test
    public void correctAssignOverdueTasks_recurringTask() throws Exception {
        recurringManager.setTestMode(false);
        correctAssignOverdueTasks(RecurringType.DAILY);
        correctAssignOverdueTasks(RecurringType.WEEKLY);
        correctAssignOverdueTasks(RecurringType.MONTHLY);
        correctAssignOverdueTasks(RecurringType.YEARLY);
    }
    
    @Test
    public void updateRecurringTask_noRecurringPeriod() throws Exception {
        recurringManager.setTestMode(true);
        updateRecurringTask(RecurringType.DAILY, "2016-10-12");
        updateRecurringTask(RecurringType.WEEKLY, "2016-10-17");
        updateRecurringTask(RecurringType.MONTHLY, "2016-11-12");
        updateRecurringTask(RecurringType.YEARLY, "2017-10-11");
    }
    
    @Test
    public void updateRecurringTasks_withoutRepeatLimit() throws Exception {
        recurringManager.setTestMode(true);
        updateRecurringTask(RecurringType.DAILY, "12 oct 2016 11pm", "13 oct 2016 11pm");
        updateRecurringTask(RecurringType.WEEKLY, "18 oct 2016 11pm", "19 oct 2016 11pm");
        updateRecurringTask(RecurringType.MONTHLY, "11 nov 2016 11pm", "12 nov 2016 11pm");
        updateRecurringTask(RecurringType.YEARLY, "11 oct 2017 11pm", "12 oct 2017 11pm");
    }
    
    @Test
    public void updateRecurringTask_withRecurringPeriod() throws Exception {
        final int recurringPeriod = 3;
        updateRecurringTask_withRecurringPeriod(RecurringType.DAILY, recurringPeriod, null, "14 oct 2016 11pm");
        updateRecurringTask_withRecurringPeriod(RecurringType.WEEKLY, recurringPeriod, null, "26 oct 2016 11pm");
        updateRecurringTask_withRecurringPeriod(RecurringType.MONTHLY, recurringPeriod, null, "12 dec 2016 11pm");
        updateRecurringTask_withRecurringPeriod(RecurringType.YEARLY, recurringPeriod, null, "12 oct 2018 11pm");
    }

    private void correctAssignOverdueTasks(RecurringType type) throws Exception {
        TestTask tryCorrect = helper.buildRecurringTask(type);
        TestTask expectedTask = helper.buildRecurringTask(type);
        assert_correctAssignOverdueTasks(tryCorrect, expectedTask, type);      
    }
    
    private void assert_correctAssignOverdueTasks(TestTask tryCorrect, TestTask expectedTask, RecurringType type)
            throws IllegalValueException {
        recurringManager.correctAddingOverdueTasks(tryCorrect, helper.getLocalDateByString("2016-10-12"));
        assertThat("Recurring tasks should be corrected", 
                helper.getLastAppendedOccurrence(tryCorrect), is(not(helper.getLastAppendedOccurrence(expectedTask))));
        recurringManager.correctAddingOverdueTasks(tryCorrect, helper.getLocalDateByString("2017-11-12"));
        assertThat("Recurring tasks should be corrected",
                helper.getLastAppendedOccurrence(tryCorrect), is(not(helper.getLastAppendedOccurrence(expectedTask))));
        tryCorrect = helper.buildRecurringTask(type);
        recurringManager.correctAddingOverdueTasks(tryCorrect, helper.getLocalDateByString("2016-10-09"));
        assertEquals("Recurring tasks should be corrected",
                helper.getLastAppendedOccurrence(tryCorrect), helper.getLastAppendedOccurrence(expectedTask));
    }
    
    public void updateRecurringTask(RecurringType type, String dateToAppendTask) throws Exception {
        TestTask tryAppend = helper.buildRecurringTask(type);
        assert_updateRecurringTask(tryAppend, dateToAppendTask);        
    }
    
    private void assert_updateRecurringTask(TestTask tryAppend, String dateToAppendTask) {
        recurringManager.attemptAppendRecurringTask(tryAppend, helper.getLocalDateByString("2016-10-11"));
        assertEquals("Recurring tasks should not append until their date has been elapsed", tryAppend.getTaskDateComponent().size(), 1);
        recurringManager.attemptAppendRecurringTask(tryAppend, helper.getLocalDateByString(dateToAppendTask));
        assertEquals("Recurring tasks should be appended when it is time", tryAppend.getTaskDateComponent().size(), 2);                
    }        

    private void updateRecurringTask(RecurringType type, String nextStartDate, String nextEndDate) throws Exception {
        TestTask testData = helper.buildRecurringTask(type);
        Task tryUpdate = new Task(testData);
        execute_updatingOfRecurringTask(tryUpdate);
        TaskOccurrence nextDayTaskOccurrence = helper.buildTaskOccurrenceFromTask(tryUpdate, nextStartDate, nextEndDate);
        assert_updateRecurringTasks(tryUpdate, nextDayTaskOccurrence, 2);
    }

    private void execute_updatingOfRecurringTask(Task tryUpdate)
            throws Exception {
        model.addTask(tryUpdate);
        model.archiveTask(helper.getLastAppendedOccurrence(tryUpdate));
    }
    
    private void assert_updateRecurringTasks(Task tryUpdate, TaskOccurrence nextDayTaskOccurrence, final int numOfOccurrences) {
        assertEquals("The following daily task should have been created", tryUpdate.getTaskDateComponent().size(), numOfOccurrences);
        assertEquals("Daily task should match in task occurrence", tryUpdate.getLastAppendedComponent(), nextDayTaskOccurrence);
    }    
    
    private void updateRecurringTask_withRecurringPeriod(RecurringType type, int recurringPeriod,
            String nextStartDate, String nextEndDate) throws Exception {
        TestTask testData = helper.buildRecurringTask_withoutStartDate(type, recurringPeriod);
        Task tryUpdate = new Task(testData);
        execute_updatingOfRecurringTask(tryUpdate);
        TaskOccurrence nextDayTaskOccurrence = helper.buildTaskOccurrenceFromTask(tryUpdate, nextStartDate, nextEndDate);
        assert_updateRecurringTasks(tryUpdate, nextDayTaskOccurrence, recurringPeriod);
    }    


    class RecurringTaskHelper {
        private static final int RECURRING_PERIOD_OFFSET = 1;
        private TaskBuilder builder;
        
        public LocalDate getLocalDateByString(String dateToConsider) {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
            formatter = formatter.withLocale(Locale.getDefault());  // Locale specifies human language for translating, and cultural norms for lowercase/uppercase and abbreviations and such. Example: Locale.US or Locale.CANADA_FRENCH
            LocalDate date = LocalDate.parse(dateToConsider, formatter);
            return date;
        }
        
        public Calendar getLastAppendedStartDate(ReadOnlyTask task) {
            Calendar cal = new GregorianCalendar();
            cal.setTime(task.getLastAppendedComponent().getStartDate().getDate());
            return cal;
        }
        
        public Calendar getLastAppendedEndDate(ReadOnlyTask task) {
            Calendar cal = new GregorianCalendar();
            cal.setTime(task.getLastAppendedComponent().getEndDate().getDate());
            return cal;
        }
        
        public TestTask buildRecurringTask(RecurringType type) throws IllegalValueException {
            return buildRecurringTask(type, 0);
        }
        
        public TestTask buildRecurringTask(RecurringType type, int recurringPeriod) throws IllegalValueException {
            builder = new TaskBuilder();
            return builder.withName("recurring").withStartDate("11 oct 2016 11pm").withEndDate("12 oct 2016 11pm")
                    .withRecurringType(type).withRecurringPeriod(recurringPeriod - RECURRING_PERIOD_OFFSET).build();
        }
        
        public TestTask buildNonRecurringTask_withStartDate() throws IllegalValueException {
            builder = new TaskBuilder();
            return builder.withName("non recurring").withStartDate("11 oct 2016 11pm")
                    .withEndDate("12 oct 2016 11pm").build();
        }
        
        public TestTask buildRecurringTask_withoutStartDate(RecurringType type, int recurringPeriod) throws IllegalValueException {
            builder = new TaskBuilder();
            return builder.withName("recurring").withEndDate("12 oct 2016 11pm")
                    .withRecurringType(type).withRecurringPeriod(recurringPeriod - 1).build();
        }                
        
        public TaskOccurrence getLastAppendedOccurrence(ReadOnlyTask task) {
            int listLen = task.getTaskDateComponent().size();
            TaskOccurrence toReturn = task.getTaskDateComponent().get(listLen-1);
            toReturn.setTaskReferrence((Task) task);
            return toReturn;
        }
        
        public TaskOccurrence buildTaskOccurrenceFromTask(ReadOnlyTask task, String startDate, String endDate) {
            TaskOccurrence toBuild = new TaskOccurrence(task.getLastAppendedComponent());
            toBuild = changeStartDate(toBuild, startDate);
            toBuild = changeEndDate(toBuild, endDate);
            return toBuild;
        }
        
        public TaskOccurrence changeStartDate(TaskOccurrence occurrence, String startDate) {
            TaskOccurrence toChange = new TaskOccurrence(occurrence);
            if (startDate == null) {
                toChange.setStartDate(new TaskDate(TaskDate.DATE_NOT_PRESENT));
                return toChange;
            }
            toChange.setStartDate(new TaskDate(startDate));
            return toChange;
        }
        
        public TaskOccurrence changeEndDate(TaskOccurrence occurrence, String endDate) {
            TaskOccurrence toChange = new TaskOccurrence(occurrence);
            toChange.setEndDate(new TaskDate(endDate));
            return toChange;
        }
    }
}
```
###### \java\seedu\address\model\task\stub\NameStub.java
``` java
public class NameStub extends Name {

    private static final String DUMMY_NAME = "dummy";

    public NameStub() throws IllegalValueException {
        this(DUMMY_NAME);
    }
    public NameStub(String name) throws IllegalValueException {
        super(name);
    }
    
    @Override
    public String toString() {
        return "";
    }
}
```
###### \java\seedu\address\model\task\stub\TaskDateStub.java
``` java
public class TaskDateStub extends TaskDate {
    public String getFormattedDate() {
        return "";
    }
    
    //For sake of testing
    @Override
    public String getInputDate() {
        return "";
    }
    
    @Override
    public long getDateInLong() {
        return TaskDate.DATE_NOT_PRESENT;
    } 
    
    /**
     * Parses the date in Long and provides it in the Date class format
     */
    @Override
    public Date getDate() {
        return new Date(0);
    }
    
    @Override
    public boolean equals(Object other){
        return true;
    }

    @Override
    public boolean isPresent() {
        return true;
    }
    
    @Override
    public String toString() {
        return "";
    }   
}
```
###### \java\seedu\address\model\task\stub\TaskOccurrenceStub.java
``` java
public class TaskOccurrenceStub extends TaskOccurrence {

    public TaskOccurrenceStub(TaskStub taskReference, TaskDateStub startDate, TaskDateStub endDate) {
        super(taskReference, startDate, endDate);
    }
    public TaskOccurrenceStub(Task taskReference, TaskDateStub startDate, TaskDateStub endDate) {
        super(taskReference, startDate, endDate);
    }
}
```
###### \java\seedu\address\model\task\stub\TaskStub.java
``` java
public class TaskStub extends Task {
    private NameStub name;
    public TaskStub(Name name, UniqueTagList tags) throws IllegalValueException {   
        super(name, tags);
    }
    public TaskStub() throws IllegalValueException {
        name = new NameStub("dummy");
        new ArrayList<TaskOccurrenceStub>();
    }
    @Override
    public Name getName() {
        return name;
    }

    public void setTaskType(TaskType type) {
    }
    
    public void setRecurringType(RecurringType type) {
    }
    public void setRecurringDates(List<TaskOccurrence> newComponentList){
    }
    /**
     * Replaces this task's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
    }

    @Override
    public boolean equals(Object other) {
        return true;
    }
    
    @Override
    public TaskType getTaskType() {
        return TaskType.NON_FLOATING;
    }
    @Override
    public RecurringType getRecurringType() {
        return RecurringType.NONE;
    }

    @Override
    public String toString() {
        return "";
    }
    @Override
    public void completeTaskWhenAllOccurrencesArchived() {
    }
    @Override
    public void updateTask(Name name, UniqueTagList tags, TaskDate startDate, TaskDate endDate, RecurringType recurringType, int index) {
    }
    
    @Override
    public TaskOccurrenceStub getLastAppendedComponent() {
        return new TaskOccurrenceStub(this,new TaskDateStub(), new TaskDateStub());
    }
    
    @Override
    public List<TaskOccurrence> getTaskDateComponent() {
        List<TaskOccurrence> occurrences = new ArrayList<TaskOccurrence>();
        occurrences.add(getLastAppendedComponent());
        return occurrences;
    }

    @Override
    public void appendRecurringDate(TaskOccurrence componentToBeAdded) {
    }
}
```
###### \java\seedu\address\model\task\stub\UniqueTagListStub.java
``` java
public class UniqueTagListStub extends UniqueTagList {
    /**
     * All tags in this list as a Set. This set is mutable and change-insulated against the internal list.
     */
    public Set<Tag> toSet() {
        return null;
    }

    /**
     * Replaces the Tags in this list with those in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
    }

    /**
     * Adds every tag from the argument list that does not yet exist in this list.
     */
    public void mergeFrom(UniqueTagList tags) {
    }

    /**
     * Returns true if the list contains an equivalent Tag as the given argument.
     */
    public boolean contains(Tag toCheck) {
        return true;
    }

    /**
     * Adds a Tag to the list.
     *
     * @throws DuplicateTagException if the Tag to add is a duplicate of an existing Tag in the list.
     */
    @Override
    public void add(Tag toAdd) throws DuplicateTagException {
    }


    @Override
    public boolean equals(Object other) {
        return true;
    }

}
```
###### \java\seedu\address\model\task\TaskTester.java
``` java
/**
 * Unit Tester that tests the methods of the Task class
 *
 */
public class TaskTester {
    private Task task;
    private TaskTesterHelper helper;
    
    @Before
    public void setup() {
        helper = new TaskTesterHelper();
    }
    
    @Test
    public void create_task() throws Exception {
        task = helper.createFloatingTask();
        assertEquals(task.getTaskType(), TaskType.FLOATING);
        task = helper.createNonFloatingTask(RecurringType.NONE);
        assertEquals(task.getTaskType(), TaskType.NON_FLOATING);
    }
    
    @Test(expected=AssertionError.class)
    public void setRecurringType_floatingTask_throwAssert() throws Exception {
        task = helper.createFloatingTask();
        task.setRecurringType(RecurringType.DAILY);
    }

    @Test
    public void setRecurringType_successful() throws Exception {
        task = helper.createNonFloatingTask(RecurringType.NONE);
        task.setRecurringType(RecurringType.DAILY);
        assertEquals(task.getRecurringType(), RecurringType.DAILY);
    }

    @Test
    public void setTaskType_successful() throws Exception {
        task = helper.createNonFloatingTask(RecurringType.NONE);
        task.setTaskType(TaskType.COMPLETED);
        assertEquals("Task type should be mutated", task.getTaskType(), TaskType.COMPLETED);
    }

    @Test(expected=AssertionError.class)
    public void appendTaskComponent_toNonRecurringTask_notAllowed() throws Exception {
        task = helper.createNonFloatingTask(RecurringType.NONE);
        TaskOccurrenceStub toAppend = helper.createTaskOccurenceStub(task);
        task.appendRecurringDate(toAppend);
    }

    @Test
    public void getLastAppendedComponent_success() throws Exception {
        task = helper.createNonFloatingTask(RecurringType.DAILY);
        TaskOccurrenceStub toAppend = helper.createTaskOccurenceStub(task);
        task.appendRecurringDate(toAppend);
        TaskOccurrenceStub component = (TaskOccurrenceStub) task.getLastAppendedComponent();
        assertEquals("Task component just appended must be the last appended component", toAppend, component);
        assertEquals("Task occurrences should be properly appended", task.getTaskDateComponent().size(), 2);
    }
    
    class TaskTesterHelper {
        public Task createFloatingTask() throws IllegalValueException {
            return new Task(new NameStub("dummy"), new UniqueTagListStub());
        }
        
        public Task createNonFloatingTask(RecurringType type) throws IllegalValueException {
            return new Task(new NameStub("dummy"), new UniqueTagListStub(),
                    new TaskDateStub(), new TaskDateStub(), type, Task.NO_RECURRING_PERIOD);
        }
        
        public TaskOccurrenceStub createTaskOccurenceStub(Task task) {
            return new TaskOccurrenceStub(task, new TaskDateStub(), new TaskDateStub());
        }
    }
}
```
###### \java\seedu\address\model\task\UniqueTaskListTest.java
``` java
/**
 * Tests methods that have not been fully covered in the other tests
 *
 */
public class UniqueTaskListTest {
    UniqueTaskList taskList;
    UniqueTaskListHelper helper;
    @Before
    public void setUp() {
        taskList = new UniqueTaskList();
        helper = new UniqueTaskListHelper();
    }
    
    @Test
    public void addToTaskList_unitTest() throws Exception {
        taskList.add(new TaskStub());
        assert_taskList_contentMatch(1, 1);
    }
    
    @Test
    public void addToTaskList_integrationTest() throws Exception {
        Task toAdd = new Task(new NameStub(), new UniqueTagListStub());
        taskList.add(toAdd);
        assert_taskList_contentMatch(1, 1);
    }
    
    @Test
    public void add_duplicate_recurring_tasks_successful() throws Exception {
        TestTask toAdd = helper.buildNonFloatingTask(RecurringType.DAILY, "11oct 2016 11pm", "12oct 2016 12pm");
        TestTask toAddRecurring = helper.buildNonFloatingTask(RecurringType.DAILY, "12oct 2016 11pm", "13oct 2016 12pm");
        taskList.add(toAdd);
        taskList.add(toAddRecurring);
        assert_taskList_contentMatch(1, 2);
    }
    
    @Test(expected = DuplicateTaskException.class)
    public void add_duplicate_non_recurring_tasks_throwException() throws Exception {
        TestTask toAdd = helper.buildNonFloatingTask(RecurringType.DAILY, "11oct 2016 11pm", "12oct 2016 12pm");
        TestTask toAddRecurring = helper.buildNonFloatingTask(RecurringType.NONE, "12oct 2016 11pm", "13oct 2016 12pm");
        taskList.add(toAdd);
        taskList.add(toAddRecurring);
    }
    
    @Test(expected = TaskNotFoundException.class)
    public void remove_task_that_does_not_exist() throws Exception {
        TestTask toRemove = helper.buildNonFloatingTask(RecurringType.DAILY, "11oct 2016 11pm", "12oct 2016 12pm");
        taskList.remove(toRemove);
    }
    
    private void assert_taskList_contentMatch(final int numOfTasks, final int numOfOccurrence) {
        assertEquals(taskList.getInternalTaskList().size(), numOfTasks);
        assertEquals(taskList.getInternalOccurrenceList().size(), numOfOccurrence);
    }
    
    class UniqueTaskListHelper {
        TestTask buildNonFloatingTask(RecurringType type, String startDate, String endDate) throws Exception {
            TaskBuilder builder = new TaskBuilder();
            return builder.withName("Non Floating Task").withStartDate(startDate)
                    .withEndDate(endDate).withRecurringType(type).build();
        }
    }
}
```
###### \java\seedu\address\model\util\RecurringTaskUtilTest.java
``` java
public class RecurringTaskUtilTest {
    private static final String CURRENT_DATE = "2016-10-13";
    RecurringTaskUtilHelper helper;
    
    @Before
    public void setup() {
        helper = new RecurringTaskUtilHelper();
    }
    
    @Test
    public void getNumElapsedTaskToAppend() {
        getNumElapsedTaskToAppend_daily();
        getNumElapsedTaskToAppend_weekly();
        getNumElapsedTaskToAppend_monthly();
        getNumElapsedTaskToAppend_yearly();
    }
    
    public void getNumElapsedTaskToAppend_daily() {
        int numElapsed = RecurringTaskUtil.getElapsedPeriodToAppend(
                helper.getLocalDateByString(CURRENT_DATE), null, helper.getLocalDateByString("2016-10-11"), RecurringType.DAILY);
        assertEquals(numElapsed, 2);
        numElapsed = RecurringTaskUtil.getElapsedPeriodToAppend(
                helper.getLocalDateByString(CURRENT_DATE), helper.getLocalDateByString("2016-10-11"), helper.getLocalDateByString("2016-10-12"), RecurringType.DAILY);
        assertEquals(numElapsed, 2);        
    } 

    public void getNumElapsedTaskToAppend_weekly() {
        int numElapsed = RecurringTaskUtil.getElapsedPeriodToAppend(
                helper.getLocalDateByString(CURRENT_DATE), null, helper.getLocalDateByString("2016-10-11"), RecurringType.WEEKLY);
        assertEquals(numElapsed, 1);
        numElapsed = RecurringTaskUtil.getElapsedPeriodToAppend(
                helper.getLocalDateByString(CURRENT_DATE), helper.getLocalDateByString("2016-10-11"), helper.getLocalDateByString("2016-10-12"), RecurringType.WEEKLY);
        assertEquals(numElapsed, 1);    
    }     

    public void getNumElapsedTaskToAppend_monthly() {
        int numElapsed = RecurringTaskUtil.getElapsedPeriodToAppend(
                helper.getLocalDateByString(CURRENT_DATE), null, helper.getLocalDateByString("2016-09-11"), RecurringType.MONTHLY);
        assertEquals(numElapsed, 1);
        numElapsed = RecurringTaskUtil.getElapsedPeriodToAppend(
                helper.getLocalDateByString(CURRENT_DATE), helper.getLocalDateByString("2016-09-11"), helper.getLocalDateByString("2016-09-12"), RecurringType.MONTHLY);
        assertEquals(numElapsed, 1);
    }

    public void getNumElapsedTaskToAppend_yearly() {
        int numElapsed = RecurringTaskUtil.getElapsedPeriodToAppend(
                helper.getLocalDateByString(CURRENT_DATE), null, helper.getLocalDateByString("2015-10-11"), RecurringType.YEARLY);
        assertEquals(numElapsed, 1);
        numElapsed = RecurringTaskUtil.getElapsedPeriodToAppend(
                helper.getLocalDateByString(CURRENT_DATE), helper.getLocalDateByString("2015-10-11"), helper.getLocalDateByString("2015-10-12"), RecurringType.YEARLY);
        assertEquals(numElapsed, 1);
    }

    class RecurringTaskUtilHelper {
        public LocalDate getLocalDateByString(String dateToConsider) {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
            formatter = formatter.withLocale(Locale.getDefault());  // Locale specifies human language for translating, and cultural norms for lowercase/uppercase and abbreviations and such. Example: Locale.US or Locale.CANADA_FRENCH
            LocalDate date = LocalDate.parse(dateToConsider, formatter);
            return date;
        }
    }
}
```
