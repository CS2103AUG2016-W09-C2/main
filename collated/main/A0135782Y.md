# A0135782Y
###### \java\seedu\address\logic\RecurringTaskManager.java
``` java
/**
 * Handles the behaviour of recurring tasks
 * Dictates when should the recurring tasks be shown
 * This class is using a singleton pattern.
 * Use RecurringTaskManager.getInstance() to get the instance of the class
 */
public class RecurringTaskManager {
    private static final int APPEND_INCREMENT = 1;
    private static final double NUM_MONTHS_IN_YEAR = 12.0;
    private static final double NUM_WEEKS_IN_MONTH = 4.0;
    private static final double NUM_DAYS_IN_WEEK = 7.0;
    private static final int NUMBER_OF_DAYS_IN_A_WEEK = 7;
    private static RecurringTaskManager instance;
    private static final Logger logger = LogsCenter.getLogger(MainApp.class);
    
    private UniqueTaskList repeatingTasks;
    private RecurringTaskManager() {}
    
    public void setTaskList(UniqueTaskList referenceList) {
        assert referenceList != null : "Reference Task list cannot be null";
        logger.fine("Initializing with RecurringTaskManager to manage: " + referenceList.toString());
        repeatingTasks = referenceList;
    }
    
    public void updateAnyRecurringTasks() {
        assert repeatingTasks != null : "Repeating Task list reference cannot be null";
        logger.info("=============================[ RecurringTaskManager Updating ]===========================");
        for(ReadOnlyTask task : repeatingTasks){
            if (task.getRecurringType().equals(RecurringType.NONE)) {
                continue;
            }
            updateRecurringTask(task);
        }
    }
    
    /**
     * Corrects the recurring task that are overdued to reflect the present and future recurring dates
     * 
     * @param task Added task that might have dates that are overdued at the start
     */
    public void correctAddingOverdueTasks(Task task) {
        assert task != null : "task that needs correcting cannot be null!";
        correctAddingOverdueTasks(task, LocalDate.now());
    }
    
    /**
     * Helps to correct date till a certain date.
     * Helps with testing of the correcting of date.
     * 
     * @param task Task to be correct, cannot be null
     * @param currentDate LocalDate that we are correcting towards, cannot be null
     */
    public void correctAddingOverdueTasks(Task task, LocalDate currentDate) {
        assert !CollectionUtil.isAnyNull(task,currentDate);
        if (task.getRecurringType().equals(RecurringType.NONE)) {
            return;
        }
        LocalDate localDateCurrently = currentDate;
        LocalDate startDateInLocalDate = null;
        if (!task.getComponentForNonRecurringType().hasOnlyEndDate()) {
            startDateInLocalDate = task.getComponentForNonRecurringType().getStartDate().getDate()
                    .toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        }
        LocalDate endDateInLocalDate = task.getComponentForNonRecurringType().getEndDate().getDate()
                .toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        switch(task.getRecurringType()) {
            case DAILY:
                attemptCorrectDailyRecurringTask(task, localDateCurrently, startDateInLocalDate, endDateInLocalDate);
                break;
            case WEEKLY:
                attemptCorrectWeeklyRecurringTask(task, localDateCurrently, startDateInLocalDate, endDateInLocalDate);
                break;
            case MONTHLY:
                attemptCorrectMonthlyRecurringTask(task, localDateCurrently, startDateInLocalDate, endDateInLocalDate);
                break;
            case YEARLY:
                attempCorrectYearlyRecurringTask(task, localDateCurrently, startDateInLocalDate, endDateInLocalDate);                
                break;
            default:
                assert false : "Recurring Type must always be specified";
                break;
        }        
    }

    /**
     * Corrects recurring tasks that are overdued to the next possible recurring slot.
     * Does not correct the tasks if it is not overdued.
     * 
     * @param task Task that we are interested in correcting
     * @param localDateCurrently Local date should not be null and should be the date that we are interested in.
     * @param startDateInLocalDate Converted form of start date.
     * @param endDateInLocalDate Converted form of end date.
     */
    private void attempCorrectYearlyRecurringTask(Task task, LocalDate localDateCurrently,
            LocalDate startDateInLocalDate, LocalDate endDateInLocalDate) {
        final int elapsedYear;
        if (startDateInLocalDate != null) {
            elapsedYear = (int) Math.ceil(ChronoUnit.MONTHS.between(startDateInLocalDate, localDateCurrently) / NUM_MONTHS_IN_YEAR);
        } else {
            elapsedYear = (int) Math.ceil(ChronoUnit.MONTHS.between(endDateInLocalDate, localDateCurrently) / NUM_MONTHS_IN_YEAR);
        }
        if (elapsedYear > 0) {
            correctYearlyRecurringTask(task, elapsedYear);
        } else {
            final int elapsedDay = (int) ChronoUnit.DAYS.between(startDateInLocalDate, localDateCurrently);
            if (elapsedDay > 0) {
                correctYearlyRecurringTask(task, 1);
            }
        }
    }

    /**
     * Corrects recurring tasks that are overdued to the next possible recurring slot.
     * Does not correct the tasks if it is not overdued.
     * 
     * @param task Task that we are interested in correcting
     * @param localDateCurrently Local date should not be null and should be the date that we are interested in.
     * @param startDateInLocalDate Converted form of start date.
     * @param endDateInLocalDate Converted form of end date.
     */
    private void attemptCorrectMonthlyRecurringTask(Task task, LocalDate localDateCurrently,
            LocalDate startDateInLocalDate, LocalDate endDateInLocalDate) {
        final int elapsedMonth;
        if (startDateInLocalDate != null) {
            elapsedMonth = (int) Math.ceil(ChronoUnit.WEEKS.between(startDateInLocalDate, localDateCurrently) / NUM_WEEKS_IN_MONTH);
        } else {
            elapsedMonth = (int) Math.ceil(ChronoUnit.WEEKS.between(endDateInLocalDate, localDateCurrently) / NUM_WEEKS_IN_MONTH);
        }
        if(elapsedMonth > 0) {
            correctMonthlyRecurringTask(task, elapsedMonth);
        } else {
            final int elapsedDay = (int) ChronoUnit.DAYS.between(startDateInLocalDate, localDateCurrently);
            if (elapsedDay > 0) {
                correctMonthlyRecurringTask(task, 1);
            }
        }
    }

    /**
     * Corrects recurring tasks that are overdued to the next possible recurring slot.
     * Does not correct the tasks if it is not overdued.
     * 
     * @param task Task that we are interested in correcting
     * @param localDateCurrently Local date should not be null and should be the date that we are interested in.
     * @param startDateInLocalDate Converted form of start date.
     * @param endDateInLocalDate Converted form of end date.
     */
    private void attemptCorrectWeeklyRecurringTask(Task task, LocalDate localDateCurrently,
            LocalDate startDateInLocalDate, LocalDate endDateInLocalDate) {
        final int elapsedWeek;
        if (startDateInLocalDate != null) {
            elapsedWeek =  (int) (ChronoUnit.DAYS.between(startDateInLocalDate, localDateCurrently) / NUM_DAYS_IN_WEEK);
        } else {
            elapsedWeek =  (int) (ChronoUnit.DAYS.between(endDateInLocalDate, localDateCurrently) / NUM_DAYS_IN_WEEK);
        }
        if(elapsedWeek > 0) {
            correctWeeklyRecurringTask(task, elapsedWeek);
        } else {
            final int elapsedDay = (int) ChronoUnit.DAYS.between(startDateInLocalDate, localDateCurrently);
            if (elapsedDay > 0) {
                correctWeeklyRecurringTask(task, 1);
            }
        }
    }

    /**
     * Corrects recurring tasks that are overdued to the next possible recurring slot.
     * Does not correct the tasks if it is not overdued.
     * 
     * @param task Task that we are interested in correcting
     * @param localDateCurrently Local date should not be null and should be the date that we are interested in.
     * @param startDateInLocalDate Converted form of start date.
     * @param endDateInLocalDate Converted form of end date.
     */
    private void attemptCorrectDailyRecurringTask(Task task, LocalDate localDateCurrently,
            LocalDate startDateInLocalDate, LocalDate endDateInLocalDate) {
        final int elapsedDay;
        if (startDateInLocalDate != null) {
            elapsedDay = (int) ChronoUnit.DAYS.between(startDateInLocalDate, localDateCurrently);
        } else {
            elapsedDay = (int) ChronoUnit.DAYS.between(endDateInLocalDate, localDateCurrently);
        }
        if(elapsedDay > 0) {
            correctDailyRecurringTask(task, elapsedDay);
        }
    }

    /**
     * Corrects the overdued yearly tasks.
     * 
     * @param task Task that we are correcting. 
     * @param elapsedYear How many years to correct to.
     */
    private void correctYearlyRecurringTask(ReadOnlyTask task, int elapsedYear) {
        Calendar calendar = Calendar.getInstance();
        TaskDate correctedStartDate = new TaskDate();
        TaskDate correctedEndDate = new TaskDate();
        TaskDate startDate = task.getComponentForNonRecurringType().getStartDate();
        TaskDate endDate = task.getComponentForNonRecurringType().getEndDate();
        
        if(!task.getComponentForNonRecurringType().hasOnlyEndDate()) {
            calendar.setTime(startDate.getDate());
            calendar.add(Calendar.YEAR, elapsedYear);
            correctedStartDate.setDateInLong(calendar.getTime().getTime());
        }else {
            correctedStartDate.setDateInLong((new TaskDate()).getDateInLong());
        }

        calendar.setTime(endDate.getDate());
        calendar.add(Calendar.YEAR, elapsedYear);
        correctedEndDate.setDateInLong(calendar.getTime().getTime());      
        
        task.getComponentForNonRecurringType().setStartDate(correctedStartDate);
        task.getComponentForNonRecurringType().setEndDate(correctedEndDate);
    }

    /**
     * Corrects the overdued monthly tasks.
     * 
     * @param task Task that we are correcting.
     * @param elapsedMonth How many months to correct to.
     */    
    private void correctMonthlyRecurringTask(ReadOnlyTask task, int elapsedMonth) {
        Calendar calendar = Calendar.getInstance();
        TaskDate correctedStartDate = new TaskDate();
        TaskDate correctedEndDate = new TaskDate();
        TaskDate startDate = task.getComponentForNonRecurringType().getStartDate();
        TaskDate endDate = task.getComponentForNonRecurringType().getEndDate();
        
        if(!task.getComponentForNonRecurringType().hasOnlyEndDate()) {
            calendar.setTime(startDate.getDate());
            calendar.add(Calendar.MONTH, elapsedMonth);
            correctedStartDate.setDateInLong(calendar.getTime().getTime());
        }else {
            correctedStartDate.setDateInLong((new TaskDate()).getDateInLong());
        }

        calendar.setTime(endDate.getDate());
        calendar.add(Calendar.MONTH, elapsedMonth);
        correctedEndDate.setDateInLong(calendar.getTime().getTime());        
        
        task.getComponentForNonRecurringType().setStartDate(correctedStartDate);
        task.getComponentForNonRecurringType().setEndDate(correctedEndDate);
    }

    /**
     * Corrects the overdued weekly tasks.
     * 
     * @param task Task that we are correcting.
     * @param elapsedWeek How many weeks to correct to.
     */
    private void correctWeeklyRecurringTask(ReadOnlyTask task, int elapsedWeek) {
        Calendar calendar = Calendar.getInstance();
        TaskDate correctedStartDate = new TaskDate();
        TaskDate correctedEndDate = new TaskDate();
        TaskDate startDate = task.getComponentForNonRecurringType().getStartDate();
        TaskDate endDate = task.getComponentForNonRecurringType().getEndDate();
        
        if(!task.getComponentForNonRecurringType().hasOnlyEndDate()) {
            calendar.setTime(startDate.getDate());
            calendar.add(Calendar.DAY_OF_MONTH, elapsedWeek * NUMBER_OF_DAYS_IN_A_WEEK);
            correctedStartDate.setDateInLong(calendar.getTime().getTime());
        }else {
            correctedStartDate.setDateInLong((new TaskDate()).getDateInLong());
        }

        calendar.setTime(endDate.getDate());
        calendar.add(Calendar.DAY_OF_MONTH, elapsedWeek * NUMBER_OF_DAYS_IN_A_WEEK);
        correctedEndDate.setDateInLong(calendar.getTime().getTime());
        
        task.getComponentForNonRecurringType().setStartDate(correctedStartDate);
        task.getComponentForNonRecurringType().setEndDate(correctedEndDate);
    }

    /**
     * Corrects the overdued daily tasks.
     * 
     * @param task Task that we are correcting.
     * @param elapsedDays How many days to correct to.
     */    
    private void correctDailyRecurringTask(Task task, int elapsedDay) {
        Calendar calendar = Calendar.getInstance();
        TaskDate correctedStartDate = new TaskDate();
        TaskDate correctedEndDate = new TaskDate();
        TaskDate startDate = task.getComponentForNonRecurringType().getStartDate();
        TaskDate endDate = task.getComponentForNonRecurringType().getEndDate();
        
        if(!task.getComponentForNonRecurringType().hasOnlyEndDate()) {
            calendar.setTime(startDate.getDate());
            calendar.add(Calendar.DAY_OF_MONTH, elapsedDay);
            correctedStartDate.setDateInLong(calendar.getTime().getTime());
        }else {
            correctedStartDate.setDateInLong((new TaskDate()).getDateInLong());
        }

        calendar.setTime(endDate.getDate());
        calendar.add(Calendar.DAY_OF_MONTH, elapsedDay);
        correctedEndDate.setDateInLong(calendar.getTime().getTime());
        
        task.getComponentForNonRecurringType().setStartDate(correctedStartDate);
        task.getComponentForNonRecurringType().setEndDate(correctedEndDate);
    }

    /**
     * @param Updates recurring tasks to append a new date when their recurring period has elapsed
     * @return True if the recurring task has been updated
     *          False if the recurring tasks has not been updated;
     */
    private void updateRecurringTask(ReadOnlyTask task) {
        Calendar startDate = new GregorianCalendar();
        Calendar endDate = new GregorianCalendar();
        
        List<TaskComponent> dateComponents = task.getTaskDateComponent();
        TaskComponent lastAddedComponent =  dateComponents.get(dateComponents.size()-1);
        startDate.setTime(lastAddedComponent.getStartDate().getDate());
        endDate.setTime(lastAddedComponent.getEndDate().getDate());
        
        if(!lastAddedComponent.getStartDate().isValid()) {
            startDate = null;
        }
        appendRecurringTasks(task, startDate, endDate);
    }
    
    /**
     * Appends new task when the it is time to add the recurring task.
     * Recurring tasks that pass their recurring dates will be appended to show the next task date.
     * The LocalDate is assumed to be the current system date
     * 
     * @param task Task that we are interested in
     * @param startDate Start date of the task in Calendar form to account for time zone.
     * @param endDate Start date of the task in Calendar form to account for time zone.
     */
    private void appendRecurringTasks(ReadOnlyTask task, Calendar startDate, Calendar endDate) {
        appendRecurringTasks(task,startDate,endDate,LocalDate.now());
    }

    
    /**
     * Appends new task when the it is time to add the recurring task.
     * Recurring tasks that pass their recurring dates will be appended to show the next task date.
     * 
     * @param task Task that we are interested in
     * @param startDate Start date of the task in Calendar form to account for time zone.
     * @param endDate Start date of the task in Calendar form to account for time zone.
     * @param currentDate Current date to measure the amount of tasks that have not been done.
     */
    public void appendRecurringTasks(ReadOnlyTask task, Calendar startDate, Calendar endDate, LocalDate currentDate) {
        assert !CollectionUtil.isAnyNull(task, startDate, endDate, currentDate);
        LocalDate localDateCurrently = currentDate;
        LocalDate startDateInLocalDate = null;
        if (startDate != null) {
            startDateInLocalDate = startDate.getTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        }
        LocalDate endDateInLocalDate = endDate.getTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        switch (task.getRecurringType()) {
            case DAILY:
                attemptAppendDailyRecurringTasks(task, startDate, endDate, 
                        localDateCurrently, startDateInLocalDate, endDateInLocalDate);
                break;
            case WEEKLY:
                attempAppendWeeklyRecurringTasks(task, startDate, endDate, 
                        localDateCurrently, startDateInLocalDate, endDateInLocalDate); 
                break;
            case MONTHLY:
                attemptAppendMonthlyRecurringTasks(task, startDate, endDate,
                        localDateCurrently, startDateInLocalDate, endDateInLocalDate);
                break;
            case YEARLY:
                attemptAppendYearlyRecurringTasks(task, startDate, endDate, 
                        localDateCurrently, startDateInLocalDate, endDateInLocalDate);
                break;
            default:
                assert true : "Failed to set recurring type";
        }        
    }

    /**
     * Appends yearly recurring tasks if the task has crossed over to a new year
     * 
     * @param task Task that we are interest in
     * @param startDate Start date of the task
     * @param endDate End date of the ask
     * @param localDateCurrently Current date that we are at now
     * @param startDateInLocalDate Converted start date as a LocalDate
     * @param endDateInLocalDate Converted  end date as a LocalDate
     */
    private void attemptAppendYearlyRecurringTasks(ReadOnlyTask task, Calendar startDate, Calendar endDate,
            LocalDate localDateCurrently, LocalDate startDateInLocalDate, LocalDate endDateInLocalDate) {
        final int elapsedYear;
        if (startDateInLocalDate != null) {
            elapsedYear = (int) Math.ceil(ChronoUnit.MONTHS.between(startDateInLocalDate, localDateCurrently) / NUM_MONTHS_IN_YEAR);
        } else {
            elapsedYear = (int) Math.ceil(ChronoUnit.MONTHS.between(endDateInLocalDate, localDateCurrently) / NUM_MONTHS_IN_YEAR);
        }
        for (int i = 0; i < elapsedYear; i++) {
            appendYearlyRecurringTask(task, startDate, endDate, elapsedYear);
        }
    }

    /**
     * Appends monthly recurring tasks if the task has crossed over to a new month
     * 
     * @param task Task that we are interest in
     * @param startDate Start date of the task
     * @param endDate End date of the ask
     * @param localDateCurrently Current date that we are at now
     * @param startDateInLocalDate Converted start date as a LocalDate
     * @param endDateInLocalDate Converted  end date as a LocalDate
     */    
    private void attemptAppendMonthlyRecurringTasks(ReadOnlyTask task, Calendar startDate, Calendar endDate,
            LocalDate localDateCurrently, LocalDate startDateInLocalDate, LocalDate endDateInLocalDate) {
        final int elapsedMonth;
        if (startDateInLocalDate != null) {
            elapsedMonth = (int) Math.ceil(ChronoUnit.WEEKS.between(startDateInLocalDate, localDateCurrently) / NUM_WEEKS_IN_MONTH);
        } else {
            elapsedMonth = (int) Math.ceil(ChronoUnit.WEEKS.between(endDateInLocalDate, localDateCurrently) / NUM_WEEKS_IN_MONTH);
        }
        for (int i = 0; i < elapsedMonth; i++) {
            appendMonthlyRecurringTask(task, startDate, endDate, elapsedMonth);
        }
    }

    /**
     * Appends weekly recurring tasks if the task has crossed over to a new week
     * 
     * @param task Task that we are interest in
     * @param startDate Start date of the task
     * @param endDate End date of the ask
     * @param localDateCurrently Current date that we are at now
     * @param startDateInLocalDate Converted start date as a LocalDate
     * @param endDateInLocalDate Converted  end date as a LocalDate
     */        
    private void attempAppendWeeklyRecurringTasks(ReadOnlyTask task, Calendar startDate, Calendar endDate,
            LocalDate localDateCurrently, LocalDate startDateInLocalDate, LocalDate endDateInLocalDate) {
        final int elapsedWeek;
        if ( startDateInLocalDate != null) {
            elapsedWeek = (int) Math.ceil((ChronoUnit.DAYS.between(startDateInLocalDate, localDateCurrently) / NUM_DAYS_IN_WEEK));
        } else {
            elapsedWeek = (int) Math.ceil((ChronoUnit.DAYS.between(endDateInLocalDate, localDateCurrently) / NUM_DAYS_IN_WEEK));
        }
        for (int i = 0; i < elapsedWeek; i++) {
            appendWeeklyRecurringTask(task, startDate, endDate, elapsedWeek);
        }
    }

    /**
     * Appends daily recurring tasks if the task has crossed over to a new day
     * 
     * @param task Task that we are interest in
     * @param startDate Start date of the task
     * @param endDate End date of the ask
     * @param localDateCurrently Current date that we are at now
     * @param startDateInLocalDate Converted start date as a LocalDate
     * @param endDateInLocalDate Converted  end date as a LocalDate
     */        
    private void attemptAppendDailyRecurringTasks(ReadOnlyTask task, Calendar startDate, Calendar endDate,
            LocalDate localDateCurrently, LocalDate startDateInLocalDate, LocalDate endDateInLocalDate) {
        final int elapsedDay;
        if (startDateInLocalDate != null) {
            elapsedDay = (int) ChronoUnit.DAYS.between(startDateInLocalDate, localDateCurrently);
        } else {
            elapsedDay = (int) ChronoUnit.DAYS.between(endDateInLocalDate, localDateCurrently);
        }
        for (int i = 0; i < elapsedDay; i++) {
            appendDailyRecurringTask(task, startDate, endDate, elapsedDay);
        }
    }

    /**
     * Updates Yearly recurring tasks to the their latest date slot.
     * 
     * @param task Recurring task to be considered.
     * @param startDate The start date of this task if any. Null values represents that start date is not present.
     * @param endDate The end date of the is task.
     * @param elapsedYear The years that have elapsed.
     */
    private void appendYearlyRecurringTask(ReadOnlyTask task, Calendar startDate,
            Calendar endDate, int elapsedYear) {
        // Append a new date to the current task
        Calendar calendar = Calendar.getInstance();
        TaskDate editedStartDate = new TaskDate();
        TaskDate editedEndDate = new TaskDate();
        if(startDate != null) {
            calendar.setTime(startDate.getTime());
            calendar.add(Calendar.YEAR, APPEND_INCREMENT);
            editedStartDate.setDateInLong(calendar.getTime().getTime());
            startDate.setTime(editedStartDate.getDate());
        }else {
            editedStartDate.setDateInLong((new TaskDate()).getDateInLong());
        }

        calendar.setTime(endDate.getTime());
        calendar.add(Calendar.YEAR, APPEND_INCREMENT);
        editedEndDate.setDateInLong(calendar.getTime().getTime());
        endDate.setTime(editedEndDate.getDate());
        
        TaskComponent newAppendedDate = new TaskComponent((Task) task, editedStartDate, editedEndDate);
        task.appendRecurringDate(newAppendedDate);
        repeatingTasks.appendTaskComponent(newAppendedDate);
    }

    /**
     * Updates Monthly recurring tasks to the their latest date slot.
     * 
     * @param task Recurring task to be considered.
     * @param startDate The start date of this task if any. Null values represents that start date is not present.
     * @param endDate The end date of the is task.
     * @param elapsedYear The months that have elapsed.
     */
    private void appendMonthlyRecurringTask(ReadOnlyTask task, Calendar startDate,
            Calendar endDate, int elapsedMonth) {
        // Append a new date to the current task
        // Append a new date to the current task
        Calendar calendar = Calendar.getInstance();
        TaskDate editedStartDate = new TaskDate();
        TaskDate editedEndDate = new TaskDate();
        if(startDate != null) {
            calendar.setTime(startDate.getTime());
            calendar.add(Calendar.MONTH, APPEND_INCREMENT);
            editedStartDate.setDateInLong(calendar.getTime().getTime());
            startDate.setTime(editedStartDate.getDate());
        }else {
            editedStartDate.setDateInLong((new TaskDate()).getDateInLong());
        }

        calendar.setTime(endDate.getTime());
        calendar.add(Calendar.MONTH, APPEND_INCREMENT);
        editedEndDate.setDateInLong(calendar.getTime().getTime());
        endDate.setTime(editedEndDate.getDate());
        
        TaskComponent newAppendedDate = new TaskComponent((Task) task, editedStartDate, editedEndDate);
        task.appendRecurringDate(newAppendedDate);
        repeatingTasks.appendTaskComponent(newAppendedDate);
    }

    /**
     * Updates Weekly recurring tasks to the their latest date slot.
     * 
     * @param task Recurring task to be considered.
     * @param startDate The start date of this task if any. Null values represents that start date is not present.
     * @param endDate The end date of the is task.
     * @param elapsedYear The weeks that have elapsed.
     */
    private void appendWeeklyRecurringTask(ReadOnlyTask task, Calendar startDate,
            Calendar endDate, int elapsedWeek) {
        // Append a new date to the current task
        Calendar calendar = Calendar.getInstance();
        TaskDate editedStartDate = new TaskDate();
        TaskDate editedEndDate = new TaskDate();
        if(startDate != null) {
            calendar.setTime(startDate.getTime());
            calendar.add(Calendar.DAY_OF_MONTH, NUMBER_OF_DAYS_IN_A_WEEK);
            editedStartDate.setDateInLong(calendar.getTime().getTime());
            startDate.setTime(editedStartDate.getDate());
        }else {
            editedStartDate.setDateInLong((new TaskDate()).getDateInLong());
        }

        calendar.setTime(endDate.getTime());
        calendar.add(Calendar.DAY_OF_MONTH, NUMBER_OF_DAYS_IN_A_WEEK);
        editedEndDate.setDateInLong(calendar.getTime().getTime());
        endDate.setTime(editedEndDate.getDate());
        
        TaskComponent newAppendedDate = new TaskComponent((Task) task, editedStartDate, editedEndDate);
        task.appendRecurringDate(newAppendedDate);
        repeatingTasks.appendTaskComponent(newAppendedDate);
    }

    /**
     * Updates Daily recurring tasks to the their latest date slot.
     * 
     * @param task Recurring task to be considered.
     * @param startDate The start date of this task if any. Null values represents that start date is not present.
     * @param endDate The end date of the is task.
     * @param elapsedYear The days that have elapsed.
     */
    private void appendDailyRecurringTask(ReadOnlyTask task, Calendar startDate,
            Calendar endDate, int elapsedDay) {
        // Append a new date to the current task
        Calendar calendar = Calendar.getInstance();
        TaskDate editedStartDate = new TaskDate();
        TaskDate editedEndDate = new TaskDate();
        if(startDate != null) {
            calendar.setTime(startDate.getTime());
            calendar.add(Calendar.DAY_OF_MONTH, APPEND_INCREMENT);
            editedStartDate.setDateInLong(calendar.getTime().getTime());
            startDate.setTime(editedStartDate.getDate());
        }else {
            editedStartDate.setDateInLong((new TaskDate()).getDateInLong());
        }

        calendar.setTime(endDate.getTime());
        calendar.add(Calendar.DAY_OF_MONTH, APPEND_INCREMENT);
        editedEndDate.setDateInLong(calendar.getTime().getTime());
        endDate.setTime(editedEndDate.getDate());
        
        TaskComponent newAppendedDate = new TaskComponent((Task) task, editedStartDate, editedEndDate);
        task.appendRecurringDate(newAppendedDate);
        repeatingTasks.appendTaskComponent(newAppendedDate);
    }
    

    public static RecurringTaskManager getInstance() {
        if (instance == null) {
            instance = new RecurringTaskManager();
        }
        return instance;
    }
}
```
###### \java\seedu\address\model\ModelManager.java
``` java
    /**
     * Initializes a ModelManager with the given TaskList
     * TaskList and its variables should not be null
     */
    public ModelManager(TaskMaster src, UserPrefs userPrefs) {
        super();
        assert src != null;
        assert userPrefs != null;
        logger.fine("Initializing with address book: " + src + " and user prefs " + userPrefs);

        taskMaster = new TaskMaster(src);
        tasks = taskMaster.getTasks();
        filteredTaskComponents = new FilteredList<>(taskMaster.getTaskComponentList());
        RecurringTaskManager.getInstance().setTaskList(taskMaster.getUniqueTaskList());
        RecurringTaskManager.getInstance().updateAnyRecurringTasks();
        
    }
```
###### \java\seedu\address\model\ModelManager.java
``` java
    public ModelManager(ReadOnlyTaskMaster initialData, UserPrefs userPrefs) {
        taskMaster = new TaskMaster(initialData);
        tasks = taskMaster.getTasks();
        
        filteredTaskComponents = new FilteredList<>(taskMaster.getTaskComponentList());
        RecurringTaskManager.getInstance().setTaskList(taskMaster.getUniqueTaskList());
        RecurringTaskManager.getInstance().updateAnyRecurringTasks();
      
    }
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public synchronized void addTask(Task task) throws UniqueTaskList.DuplicateTaskException, TimeslotOverlapException {
        taskMaster.addTask(task);
        RecurringTaskManager.getInstance().correctAddingOverdueTasks(task);
        updateFilteredListToShowAll();
        indicateTaskListChanged();
    }

```
###### \java\seedu\address\model\ModelManager.java
``` java
    private class ArchiveQualifier implements Qualifier {
        private boolean isArchived;

        ArchiveQualifier(boolean isItArchive) {
            this.isArchived= isItArchive;
        }

        @Override
        public boolean run(TaskComponent task) {
            return task.isArchived() == isArchived;
        }

        @Override
        public String toString() {
            return "type=" + isArchived;
        }
    }
```
###### \java\seedu\address\model\task\RecurringType.java
``` java
public enum RecurringType {
    NONE,
    DAILY,
    WEEKLY,
    MONTHLY,
    YEARLY,
    IGNORED //Merely for parsing
}
```
###### \java\seedu\address\model\task\Task.java
``` java
    @Override
    public List<TaskComponent> getTaskDateComponent() {
        return recurringDates;
    }
    
    @Override
    public TaskType getTaskType() {
        return taskType;
    }
    @Override
    public RecurringType getRecurringType() {
        return recurringType;
    }
    
    public void setTaskType(TaskType type) {
        this.taskType = type;
    }
    
    public void setRecurringType(RecurringType type) {
        if (taskType == TaskType.FLOATING) {
            assert (!type.equals(RecurringType.NONE)) : "Floating Task cannot be a recurring task";
        }
        this.recurringType = type;
    }
```
###### \java\seedu\address\model\task\Task.java
``` java
    @Override
    public void completeTaskWhenAllComponentArchived() {
        for (TaskComponent c : recurringDates) {
            if (c.isArchived() == false || c.getTaskReference().getRecurringType() != RecurringType.NONE) {
                return;
            }
        }
        taskType = TaskType.COMPLETED;
    }
```
###### \java\seedu\address\model\task\Task.java
``` java
	@Override
	public TaskComponent getComponentForNonRecurringType() {
	    assert recurringDates.size() == 1 : "This method should only be used for non recurring tasks";
	    return recurringDates.get(0);
	}
	
	@Override
	public TaskComponent getLastAppendedComponent() {
	    return recurringDates.get(recurringDates.size()-1);
	}

	@Override
	public void appendRecurringDate(TaskComponent componentToBeAdded) {
	    assert !recurringType.equals(RecurringType.NONE) : "You cannot append new dates to non recurring tasks";
	    recurringDates.add(componentToBeAdded);
	    recurringDates.get(recurringDates.size()-1).setTaskReferrence(this);
	}
```
###### \java\seedu\address\model\task\TaskComponent.java
``` java
/** 
* This class served as the occurrence portion in an abstraction occurrence pattern.
* The abstraction is the Task and the occurrence is the TaskDateComponent.
*
*/
public class TaskComponent {

    private Task taskReference;
    private TaskDate startDate, endDate;
    private boolean isArchived;
    
    public TaskComponent(Task taskReference, TaskDate startDate, TaskDate endDate) {
        assert !CollectionUtil.isAnyNull(startDate, endDate);
        this.startDate = new TaskDate(startDate);
        this.endDate = new TaskDate(endDate);
        this.taskReference = taskReference;
    }
    
    public TaskComponent(TaskComponent taskDateComponent) {
        assert taskDateComponent != null : "Cannot pass in null values";
        this.taskReference = taskDateComponent.taskReference;
        this.startDate = taskDateComponent.startDate;
        this.endDate = taskDateComponent.endDate;
        this.isArchived = taskDateComponent.isArchived;
    }

    public void setStartDate(TaskDate startDate) {
        this.startDate = startDate;
    }
    
    public void setEndDate(TaskDate endDate) {
        this.endDate = endDate;
    }
    
    public void setTaskReferrence(Task task) {
    	this.taskReference = task;
    }
    
    public TaskDate getStartDate() {
        return startDate;
    }
    
    public TaskDate getEndDate() {
        return endDate;
    }
    
    /**
     * Checks if TaskDateComponent is in a valid time slot
     * 
     * @return True if it is in a valid time slot
     */
    public boolean isValidTimeSlot(){
        if(startDate!=null && endDate!=null){
            return (endDate.getDate()).after(startDate.getDate());
        }else{
            return true;
        }
    }
    
    /**
     * Checks if the TaskDate has only end date
     * 
     * @return True if it has only an end date.
     *          False if it also contains a start date.
     */
    public boolean hasOnlyEndDate() {
        if (startDate.getDateInLong() != TaskDate.DATE_NOT_PRESENT){
            return false;
        }
        return true;
    }
    

    public ReadOnlyTask getTaskReference() {
        return taskReference;
    }

    /**
     * Archive this task component
     */
    public void archive() {
        isArchived = true;
    }
    
```
###### \java\seedu\address\model\task\TaskDate.java
``` java
/**
 * Helper class for storing date for the Task
 */
public class TaskDate {
    public static final int DATE_NOT_PRESENT = -1;
    private long date;
    
    /**
     * Date is not present by default if nothing is specified
     * Convenience and defensive
     */
    public TaskDate() {
        this.date = DATE_NOT_PRESENT;
    }
    
    public TaskDate(Date date) {
        this.date = date.getTime();
    }
    
    public TaskDate(long date) {
        this.date = date;
    }
        
    public TaskDate(TaskDate copy) {
        this.date = copy.date;
    }
    
    //For sake of testing, not implemented in main app
    public TaskDate(String inputDate) {
        this.date = new com.joestelmach.natty.Parser().parse(inputDate).get(0).getDates().get(0).getTime();
    }
    
    public void setDateInLong(long date) {
        this.date = date;
    }
    /**
     * Formats the date in (EEE, MMM d hh.mma) format which will give MON, Oct 20 10.00PM
     * If there is no date present return empty string
     * @return Empty string if there is no date present
     *          Formatted date if there is date
     */
    public String getFormattedDate() {
        if (date == DATE_NOT_PRESENT) {
            return "";
        }
        SimpleDateFormat formatter = new SimpleDateFormat("EEE, MMM d hh.mma", Locale.ENGLISH);
        return formatter.format(new Date(date));
    }
    
    //For sake of testing
    public String getInputDate() {
        if (date == DATE_NOT_PRESENT) {
            return "";
        }
        SimpleDateFormat formatter = new SimpleDateFormat("dd MMM hha", Locale.ENGLISH);
        return formatter.format(new Date(date));
    }
    
    public long getDateInLong() {
        return date;
    } 
    
    /**
     * Parses the date in Long and provides it in the Date class format
     * @return
     */
    public Date getDate() {
    	return new Date(date);
    }
    
    @Override
    public boolean equals(Object other){
		return other == this ||
				(other instanceof TaskDate // instanceof handles nulls
		         && this.getDate().equals(((TaskDate) other).getDate()));
    }

    public boolean isValid() {
        return date != DATE_NOT_PRESENT;
    }
    
    @Override
    public String toString() {
        return getFormattedDate();
    }

}
```
###### \java\seedu\address\model\task\TaskType.java
``` java
public enum TaskType {
    FLOATING,
    NON_FLOATING, 
    COMPLETED
}
```
###### \java\seedu\address\model\task\UniqueTaskList.java
``` java
    /**
     * Adds a task to the list.
     *
     * @throws DuplicateTaskException if the task to add is a duplicate of an existing task in the list.
     * @throws TimeslotOverlapException 
     */
    public void add(Task toAdd) throws DuplicateTaskException, TimeslotOverlapException {
        assert toAdd != null;
        if (contains(toAdd)) {
            if (!toAdd.getRecurringType().equals(RecurringType.NONE)) {
                // append this "task" as date component to the task
                appendDuplicateRecurringDatesToTask(toAdd);
                return;
            }
            throw new DuplicateTaskException();
        }
        if(overlaps(toAdd)){
        	throw new TimeslotOverlapException();
        }
        internalList.add(toAdd);
        internalComponentList.addAll(toAdd.getTaskDateComponent());
    }

    private void appendDuplicateRecurringDatesToTask(Task toAdd) {
        int idx = internalList.indexOf(toAdd);
        Task toBeAppendedOn = internalList.get(idx);
        internalComponentList.add(toAdd.getComponentForNonRecurringType());
        toBeAppendedOn.appendRecurringDate(toAdd.getComponentForNonRecurringType());
    }
```
###### \java\seedu\address\storage\XmlAdaptedTaskComponent.java
``` java
    @XmlElement
    private long startDate;
    @XmlElement
    private long endDate;
    @XmlElement
    private String recurringType;
    @XmlElement
    private boolean isArchived;
```
###### \java\seedu\address\storage\XmlAdaptedTaskComponent.java
``` java
    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTaskComponent(TaskComponent source) {
        name = source.getTaskReference().getName().fullName;
        tagged = new ArrayList<>();
        for (Tag tag : source.getTaskReference().getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }

        if (source.getTaskReference().getTaskType() == TaskType.NON_FLOATING) {
            startDate = source.getStartDate().getDateInLong();
            endDate = source.getEndDate().getDateInLong();
        } else if (source.getTaskReference().getTaskType() == TaskType.FLOATING) {
            startDate = TaskDate.DATE_NOT_PRESENT;
            endDate = TaskDate.DATE_NOT_PRESENT;
        } else if(source.getTaskReference().getTaskType() == TaskType.COMPLETED){
        	startDate = source.getStartDate().getDateInLong();
            endDate = source.getEndDate().getDateInLong();
        }
        if (source.getTaskReference().getRecurringType() != RecurringType.NONE && source.isArchived()) {
            TaskDate startCopy = new TaskDate(source.getStartDate());
            TaskDate endCopy = new TaskDate(source.getEndDate());
            startDate = startCopy.getDateInLong();
            endDate = endCopy.getDateInLong();
        }
        recurringType = source.getTaskReference().getRecurringType().name();
        isArchived = source.isArchived();
    }
    
    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        final Name name = new Name(this.name);
        final UniqueTagList tags = new UniqueTagList(taskTags);
        
        if (endDate != TaskDate.DATE_NOT_PRESENT) {
            return toModelTypeNonFloating(name, tags);
        }
        return toModelTypeFloating(name, tags);
    }

    private Task toModelTypeFloating(final Name name, final UniqueTagList tags) {
    	Task task = new Task(name, tags);
    	
    	if(isArchived){
    		task.setTaskType(TaskType.COMPLETED);
        	for(TaskComponent t: task.getTaskDateComponent()){
        		t.archive();
        	}
        }
    	
        return task;
    }

    private Task toModelTypeNonFloating(final Name name, final UniqueTagList tags) {
        final TaskDate taskStartDate = new TaskDate(startDate);
        final TaskDate taskEndDate = new TaskDate(endDate);
        RecurringType toBeAdded = RecurringType.NONE;
        if (recurringType != null ) {
            toBeAdded = RecurringType.valueOf(recurringType);
        }
        
        Task task = new Task(name, tags, taskStartDate, taskEndDate, toBeAdded);
        if(isArchived){
        	task.setTaskType(TaskType.COMPLETED);
        	for(TaskComponent t: task.getTaskDateComponent()){
        		t.archive();
        	}
        }

        return task;
    }
```
###### \resources\view\TaskListCard.fxml
``` fxml
                        <Label fx:id="recurringType" minHeight="-Infinity" minWidth="-Infinity" prefHeight="21.0" prefWidth="73.0" text="\$recurringType" translateX="-145.0" translateY="25.0" />
```
