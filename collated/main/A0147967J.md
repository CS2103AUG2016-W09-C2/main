# A0147967J
###### \java\seedu\address\commons\events\model\FilePathChangeEvent.java
``` java
/** Indicates the file path of the task master should change.*/
public class FilePathChangeEvent extends BaseEvent {

    public final String newFilePath;

    public FilePathChangeEvent(String newFilePath){
        this.newFilePath = newFilePath;
    }

    @Override
    public String toString() {
        return "File path changes to :" + newFilePath;
    }
}
```
###### \java\seedu\address\commons\events\ui\AgendaTimeRangeChangedEvent.java
``` java
/**
 * Indicates a change in the displayed time range of the agenda.
 */
public class AgendaTimeRangeChangedEvent extends BaseEvent {


    private final TaskDate inputDate;
    private final List<TaskComponent> taskComponentList;

    public AgendaTimeRangeChangedEvent(TaskDate inputDate, List<TaskComponent> list){
        this.inputDate = inputDate;
        this.taskComponentList = list;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public TaskDate getInputDate() {
        return inputDate;
    }
    
    public List<TaskComponent> getData() {
        return taskComponentList;
    }
}
```
###### \java\seedu\address\commons\events\ui\FailedCommandAttemptedEvent.java
``` java
/**
 * Indicates an attempt to execute a failed command
 */
public class FailedCommandAttemptedEvent extends BaseEvent {
	

    public FailedCommandAttemptedEvent(Command command) {
    }
    

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\address\commons\events\ui\NavigationSelectionChangedEvent.java
``` java
/**
 * Represents a selection change in the Navigation Bar Panel
 */
public class NavigationSelectionChangedEvent extends BaseEvent {


    private final String newSelection;

    public NavigationSelectionChangedEvent(String newSelection){
        this.newSelection = newSelection;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public String getNewSelection() {
        return newSelection;
    }
}
```
###### \java\seedu\address\logic\commands\BlockCommand.java
``` java
/**
 * Blocks a certain time slot in the task list. 
 */
public class BlockCommand extends Command {
	
	public static final String COMMAND_WORD = "block";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Blocks a certain time slot in the schedule. "
            + "Parameters: TASK_NAME [t/TAG]...\n"
            + "Example: " + COMMAND_WORD
            + " from 2 oct 2am to 2 oct 3am t/highPriority";

    public static final String MESSAGE_SUCCESS = "Timeslot blocked: %1$s";
    public static final String MESSAGE_TIMESLOT_OCCUPIED = "This timeslot is already blocked or overlapped with existing tasks.";
    public static final String MESSAGE_ILLEGAL_TIME_SLOT = "End time must be later than Start time.";
    public static final String DUMMY_NAME = "BLOCKED SLOT";



    private final Task toBlock;

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public BlockCommand(Set<String> tags, TaskDate startDate, TaskDate endDate)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toBlock = new Task(
                new Name(DUMMY_NAME),
                new UniqueTagList(tagSet),
                new TaskDate(startDate),
                new TaskDate(endDate),
                RecurringType.NONE
        );
        if(!this.toBlock.getComponentForNonRecurringType().isValidTimeSlot()){
        	indicateAttemptToExecuteIncorrectCommand();
        	throw new IllegalValueException(MESSAGE_ILLEGAL_TIME_SLOT);
        }
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addTask(toBlock);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toBlock));
        } catch (TimeslotOverlapException e) {
        	indicateAttemptToExecuteFailedCommand();
        	urManager.popFromUndoQueue();
        	return new CommandResult(MESSAGE_TIMESLOT_OCCUPIED);
		} catch (DuplicateTaskException e) {
			assert false: "not applicable for block command";
			return new CommandResult(MESSAGE_TIMESLOT_OCCUPIED);
		}

    }

}
```
###### \java\seedu\address\logic\commands\ChangeDirectoryCommand.java
``` java
/**
 * Changes the file path of the file and exports all existing data to the specified file.
 */
public class ChangeDirectoryCommand extends Command{
	
	public static final String COMMAND_WORD = "cd";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Changes the directory for the tasklist."
            + "Parameters: FILE_PATH\n"
            + "Example: " + COMMAND_WORD
            + " D:\t.xml";

    public static final String MESSAGE_SUCCESS = "Alert: This operation is irreversible.\nFile path successfully changed to : %1$s";
    public static final String MESSAGE_IO_ERROR = "Error when saving/reading file...";
    public static final String MESSAGE_CONVENSION_ERROR = "Wrong file type/Invalid file path detected.";

    private final String filePath;
    
    public ChangeDirectoryCommand(String filePath){
    	this.filePath = filePath;
    }

	@Override
	public CommandResult execute() {
		try{
			if(!filePath.endsWith(".xml"))
				throw new DataConversionException(null);
			XmlTaskListStorage newFile = new XmlTaskListStorage(filePath);
			newFile.saveTaskList(model.getTaskMaster(), filePath);
			model.changeDirectory(filePath);
			Config config = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE).get();
			config.setTaskListFilePath(filePath);
			ConfigUtil.saveConfig(config, Config.DEFAULT_CONFIG_FILE);
			urManager.resetQueue();
			return new CommandResult(String.format(MESSAGE_SUCCESS, filePath));
		}catch (DataConversionException dce){
			indicateAttemptToExecuteIncorrectCommand();
			return new CommandResult(MESSAGE_CONVENSION_ERROR);
		}catch (IOException ioe){
			indicateAttemptToExecuteFailedCommand();
			return new CommandResult(MESSAGE_IO_ERROR);
		}
	}

}
```
###### \java\seedu\address\logic\commands\Command.java
``` java
    /**
     * Assigns an undo/redo manager to the command to manage undo/redo operation.
     */
    public void assignManager(URManager urManager) {
        this.urManager = urManager;
    }

    /**
     * Raises an event to indicate an attempt to execute a failed command
     */
    protected void indicateAttemptToExecuteFailedCommand() {
        EventsCenter.getInstance().post(new FailedCommandAttemptedEvent(this));
    }
}
```
###### \java\seedu\address\logic\commands\CompleteCommand.java
``` java
/**
 * Marks a task as done identified using it's last displayed index from the task list.
 */
public class CompleteCommand extends Command {

    public static final String COMMAND_WORD = "done";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Archives the task identified by the index number used in the last task listing. The Task will be deleted after exiting the app.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_COMPLETE_TASK_SUCCESS = "Completed Task: %1$s";

    public final int targetIndex;

    public CompleteCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }


    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<TaskComponent> lastShownList = model.getFilteredTaskComponentList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            urManager.popFromUndoQueue();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        TaskComponent taskToDelete = lastShownList.get(targetIndex - 1);

        try {
            model.archiveTask(taskToDelete);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }

        return new CommandResult(String.format(MESSAGE_COMPLETE_TASK_SUCCESS, taskToDelete.getTaskReference()));
    }
}
```
###### \java\seedu\address\logic\commands\RedoCommand.java
``` java
/**
 * Redos the previous redoable operation.
 */
public class RedoCommand extends Command{

	public static final String COMMAND_WORD = "r";
	
    public static final String MESSAGE_FAIL = "No command to redo.";

    public RedoCommand() {}

    @Override
    public CommandResult execute() {
    	
    	try {
    		Context contextToRedo = urManager.getContextToRedo();
    		urManager.addToUndoQueueUsedByRedo(model, contextToRedo.getCommand());
    		return contextToRedo.getCommand().execute();
        } catch (NoAvailableCommandException nace){
        	indicateAttemptToExecuteFailedCommand();
        	return new CommandResult(MESSAGE_FAIL);
        }
    }
}
```
###### \java\seedu\address\logic\commands\UndoCommand.java
``` java
/**
 * Undos the previous undoable operation. 
 */
public class UndoCommand extends Command{

	public static final String COMMAND_WORD = "u";
	public static final String MESSAGE_SUCCESS = "Undo successfully.";
    public static final String MESSAGE_FAIL = "No command to undo.";

    public UndoCommand() {}

    @Override
    public CommandResult execute() {
    	
    	try {
    		Context contextToUndo = urManager.getContextToUndo();
    		model.resetData(contextToUndo.getData());
    		return new CommandResult(MESSAGE_SUCCESS);
        } catch (NoAvailableCommandException nace){
        	indicateAttemptToExecuteFailedCommand();
        	return new CommandResult(MESSAGE_FAIL);
        }
    }

}
```
###### \java\seedu\address\logic\commands\ViewCommand.java
``` java
/**
 * Views the agenda for the week specified by (contains) input date.
 */
public class ViewCommand extends Command {

    public final TaskDate inputDate;
    
    private SimpleDateFormat formatter = new SimpleDateFormat("yyyy MMM dd, EEE");

    public static final String COMMAND_WORD = "view";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": View the agenda of the week specified by input date.\n"
            + "Parameters: DATE_TIME \n"
            + "Example: " + COMMAND_WORD + " next WednesDay";

    public static final String MESSAGE_UPDATE_AGENDA_SUCCESS = "Agenda Updated to Week specified by: %1$s";

    public ViewCommand(TaskDate inputDate) {
        this.inputDate = inputDate;
    }

    @Override
    public CommandResult execute() {

        EventsCenter.getInstance().post(new AgendaTimeRangeChangedEvent(inputDate, model.getTaskMaster().getTaskComponentList()));
        return new CommandResult(String.format(MESSAGE_UPDATE_AGENDA_SUCCESS, formatter.format(inputDate.getDate())));

    }

}
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
    private Command prepareBlock(String args) {
    	Matcher matcher = BLOCK_DATA_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, BlockCommand.MESSAGE_USAGE));
        }
        try {
            
            String startInput = matcher.group("startTime");
            String endInput = matcher.group("endTime");
            
            return new BlockCommand(
                    getTagsFromArgs(matcher.group("tagArguments")),
                    new TaskDate(getDateFromString(startInput).getTime()),
                    new TaskDate(getDateFromString(endInput).getTime())
                    );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
	}
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the complete task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareComplete(String args) {

        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
        }

        return new CompleteCommand(index.get());
    }
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
    /**
     * Returns the view command with input date parsed 
     * @param arguments passed by user
     * @return prepared view command
     */
    private Command prepareView(String arguments) {
		// TODO Auto-generated method stub
    	Date date;
    	try{
    		date = getDateFromString(arguments);
    	}catch(IllegalArgumentException e){
    		return new IncorrectCommand(e.getMessage());
    	}
		return new ViewCommand(new TaskDate(date));
	}
```
###### \java\seedu\address\logic\URManager.java
``` java
/**
 * Stores and provides context for undo/redo operations.
 */
public class URManager {
	
	private ArrayDeque<Context> undoQueue;
	private ArrayDeque<Context> redoQueue;
	
	/** Arbitrarily chosen number to ensure overall performance. */
	private final int MAX_TIMES = 3;
	
	public URManager(){		
		undoQueue = new ArrayDeque<Context>();
		redoQueue = new ArrayDeque<Context>();		
	}
	
	/**
	 * Adds the command to undo queue for LogicManager.
	 */
	public void addToUndoQueue(Model model, Command command){
		if(!isUndoable(command)){
			//Stop here to wait for result.
		}else{
			if(!isIgnored(command)){
				if(undoQueue.size() == MAX_TIMES) undoQueue.removeFirst();
				undoQueue.addLast(new Context(model, command));
				redoQueue.clear();
			}
		}
	}
	
	/**
	 * Pops the failed or incorrect (but not detected during parsing) command from undo queue 
	 */
	public void popFromUndoQueue(){
		undoQueue.removeLast();
	}
	
	/**
	 * Change Directory command succeeds, clear all undo and redo queue. 
	 */
	public void resetQueue(){
		undoQueue.clear();
		redoQueue.clear();
	}
	
	/**
	 * Adds the command to undo queue for redo command.
	 */
	public void addToUndoQueueUsedByRedo(Model model, Command command){
		if(!isUndoable(command)){
			undoQueue.clear();
			redoQueue.clear();
		}else{
			if(!isIgnored(command)){
				if(undoQueue.size() == MAX_TIMES) undoQueue.removeFirst();
				undoQueue.addLast(new Context(model, command));
			}
		}
	}
	
	public Context getContextToUndo() throws NoAvailableCommandException{
		try{
			Context contextToUndo = undoQueue.removeLast();
			redoQueue.addLast(contextToUndo);
			return contextToUndo;
		} catch (Exception e){
			throw new NoAvailableCommandException();
		}
	}
	
	public Context getContextToRedo() throws NoAvailableCommandException{
		try{
			Context contextToRedo = redoQueue.removeLast();
			undoQueue.addLast(contextToRedo);
			return contextToRedo;
		} catch (Exception e){
			throw new NoAvailableCommandException();
		}
	}
	
	/**
	 * Returns true if the command does not need to be added in undo/redo queue.
	 * Exclusion for view command is just tentative and needs further consideration.
	 */
	public Boolean isIgnored(Command command){
		return command instanceof RedoCommand || 
			   command instanceof UndoCommand ||
			   command instanceof ViewCommand ||
			   command instanceof IncorrectCommand;
	}
	
	/**
	 * Returns true if the command is undoable.
	 * 	Currently, only ChangeDirectoryCommand is undoable.
	 */
	public Boolean isUndoable(Command command){
		return !(command instanceof ChangeDirectoryCommand);
	}
	//=================================================================
	public class NoAvailableCommandException extends Exception{}
	
	/**
	 * Inner class for backup previous data and commands.
	 */
	public class Context{
		
		private ReadOnlyTaskMaster taskList;
		private Command command;
		Context(Model model, Command command){
			this.command = command;
			this.taskList = new TaskMaster(model.getTaskMaster());
		}
		public Command getCommand(){
			return command;			
		}
		public ReadOnlyTaskMaster getData(){
			return taskList;
		}
	}
}
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public synchronized void archiveTask(TaskComponent target) throws TaskNotFoundException {
        taskMaster.archiveTask(target);
        indicateTaskListChanged();
        updateFilteredListToShowAll();
    }
    
    @Override
	public void changeDirectory(String filePath) {
		raise(new FilePathChangeEvent(filePath));
	}
```
###### \java\seedu\address\model\ModelManager.java
``` java

    //=========== Filtered Task List Accessors ===============================================================

    @Override
    public List<ReadOnlyTask> getTaskList() {
        return new ArrayList<ReadOnlyTask>(tasks);
    }

    @Override
    public UnmodifiableObservableList<TaskComponent> getFilteredTaskComponentList() {
        return new UnmodifiableObservableList<>(filteredTaskComponents);
    }

    @Override
    public void updateFilteredListToShowAll() {
        filteredTaskComponents.setPredicate(new PredicateExpression(new ArchiveQualifier(true))::unsatisfies);       
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords, Set<String> tags, Date startDate, Date endDate, Date deadline) {
        updateFilteredTaskList(new PredicateExpression(new FindQualifier(keywords, tags, startDate, endDate, deadline)));
    }

    private void updateFilteredTaskList(Expression expression) {
        filteredTaskComponents.setPredicate(expression::satisfies);
    }

    //========== Inner classes/interfaces used for filtering ==================================================

    interface Expression {
        boolean satisfies(TaskComponent t);
        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(TaskComponent task) {
            return qualifier.run(task);
        }
        
        
        public boolean unsatisfies(TaskComponent task) {
            return !qualifier.run(task);
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(TaskComponent task);
        String toString();
    }
    
```
###### \java\seedu\address\model\ModelManager.java
``` java
    private class TypeQualifier implements Qualifier {
        private TaskType typeKeyWords;

        TypeQualifier(TaskType typeKeyWords) {
            this.typeKeyWords = typeKeyWords;
        }

        @Override
        public boolean run(TaskComponent task) {
        	return task.getTaskReference().getTaskType().equals(typeKeyWords) && !task.isArchived();
        }

        @Override
        public String toString() {
            return "type=" + typeKeyWords.toString();
        }
    }
```
###### \java\seedu\address\model\task\UniqueTaskList.java
``` java
    /**
     * Signals that an operation adding/blocking a time slot in the list would fail because
     * the timeslot is already occupied.
     */
    
    public static class TimeslotOverlapException extends DuplicateDataException {

		public TimeslotOverlapException() {
			super("Operation cannot be done due to overlapping with blocked slots.");
		}
	}
```
###### \java\seedu\address\model\task\UniqueTaskList.java
``` java
    /**
     * Returns true if the given task requests to use a blocked time slot.
     */
    public boolean overlaps(ReadOnlyTask toCheck) {
        assert toCheck != null;
        //ignore floating and deadline tasks
        if(toCheck.getComponentForNonRecurringType().getStartDate().getDateInLong() == TaskDate.DATE_NOT_PRESENT)
        	return false;
        //Only compare tasks with blocked time slots.
        for(Task t: internalList){
        	if(t.getName().fullName.equals(BlockCommand.DUMMY_NAME)){
        		if(!(!t.getComponentForNonRecurringType().getEndDate().getDate().after(toCheck.getComponentForNonRecurringType().getStartDate().getDate())||
        	        !t.getComponentForNonRecurringType().getStartDate().getDate().before(toCheck.getComponentForNonRecurringType().getEndDate().getDate())))
        	        	return true;        		
        	}
        }
        //Or if it is block command, check with existing tasks
        if(toCheck.getName().fullName.equals(BlockCommand.DUMMY_NAME)){
        	for(Task t: internalList){
        	if(t.getTaskType() == TaskType.NON_FLOATING && t.getComponentForNonRecurringType().getStartDate().getDateInLong() != TaskDate.DATE_NOT_PRESENT){
        		if(!(!t.getComponentForNonRecurringType().getEndDate().getDate().after(toCheck.getComponentForNonRecurringType().getStartDate().getDate())||
        	        !t.getComponentForNonRecurringType().getStartDate().getDate().before(toCheck.getComponentForNonRecurringType().getEndDate().getDate())))
        	        	return true;        		
        		}
        	}
        }
        return false;
    }
```
###### \java\seedu\address\model\task\UniqueTaskList.java
``` java
    /** Returns true if the specified task component is successfully archived.*/
	public boolean archive(TaskComponent target) {
		assert target != null;
        boolean taskFoundAndArchived = false;
        System.out.println(internalComponentList.contains(target));
        for(TaskComponent t : internalComponentList){
        	if(t.equals(target)){
        		t.archive();
        		taskFoundAndArchived = true;
        		t.getTaskReference().completeTaskWhenAllComponentArchived();
        	}
        }
        return taskFoundAndArchived;
	}
```
###### \java\seedu\address\model\TaskMaster.java
``` java
	public boolean archiveTask(TaskComponent target) throws TaskNotFoundException {
		// TODO Auto-generated method stub
		if (tasks.archive(target)) {
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
	}
```
###### \java\seedu\address\ui\BrowserPanel.java
``` java
    private void initialize(ObservableList<TaskComponent> taskList){
    	agenda.setDisplayedDateTime(new TaskDate(new Date(System.currentTimeMillis())));
    	loadTaskList(taskList);
    }

    public void loadTaskPage(ReadOnlyTask task) {
        //Deprecated method
    }
    
    public void updateAgenda(TaskDate inputDate, List<TaskComponent> taskList){
    	agenda.setDisplayedDateTime(inputDate);
    	loadTaskList(taskList);
    }
    
    public void reloadAgenda(List<TaskComponent> taskList){
    	loadTaskList(taskList);
    }

    /**
     * Frees resources allocated to the browser.
     */
    public void freeResources() {
        agenda = null;
    }
    
    public void loadTaskList(List<TaskComponent> taskList){   	
    	agenda.addAllToAgenda(taskList);    		
    }
    
    public MyAgenda getAgenda(){
    	return agenda;
    }
    
}
```
###### \java\seedu\address\ui\CommandBox.java
``` java
    @Subscribe
    private void handleFailedCommandAttempted(FailedCommandAttemptedEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(event,"Failed command: " + previousCommandTest +"\n"));
        setStyleToIndicateFailedCommand();
        restoreCommandText();
    }

    /**
     * Restores the command box text to the previously entered command
     */
    private void restoreCommandText() {
        commandTextField.setText(previousCommandTest);
    }

    /**
     * Sets the command box style to indicate an error
     */
    private void setStyleToIndicateIncorrectCommand() {
        commandTextField.getStyleClass().add("error");
    }
    
```
###### \java\seedu\address\ui\CommandBox.java
``` java
    /**
     * Sets the command box style to indicate a failed attempt
     */
    private void setStyleToIndicateFailedCommand() {
        commandTextField.getStyleClass().add("fail");
    }
    
    /**
     * Returns the current style class the command box used for testing purpose.
     * @return 
     */
    public ObservableList<String> getStyleClass(){
    	return commandTextField.getStyleClass();
    }
    

}
```
###### \java\seedu\address\ui\MyAgenda.java
``` java
/**
 * This class is modified from jfxtras agenda for 
 * Happy Jim Task Master Use.
 */
public class MyAgenda extends Agenda{
	
	/** Keeps track of the start and end time of agenda.*/
	private LocalDateTime agendaStartTime;
	private LocalDateTime agendaEndTime;
	
	private HashSet<ReadOnlyTask> taskSet;
	
	/** Constructor */
	public MyAgenda(){
		
		super();
		
		taskSet = new HashSet<ReadOnlyTask>();
		
		/** Sets preferred size */
		setPrefSize(550, 700);	
		
		/** Sets css class. */
		this.getStyleClass().add(MyAgenda.class.getSimpleName());
		
		/** Disables dragging and resizing appointments. The agenda is only used as a visualization. */
		allowDraggingProperty().set(false);
		allowResizeProperty().set(false);
		
		/** Disables editing via agenda */
		setEditAppointmentCallback((Callback<Appointment, Void>)(appointment)->{
			return null;			
		});
		
		/** Sets the locale used by calendar. */
		setLocale(Locale.ENGLISH);				
		
		/** Computes and sets value for variables */
		agendaStartTime = getAgendaStartDateTime();
		agendaEndTime = getAgendaEndDateTime();
		
	}
	
	//=================For change agenda range================================================
	
	/** Sets the displayed date time of the agenda to specified one. */
	public void setDisplayedDateTime(TaskDate inputDate){
		displayedLocalDateTime().set(getConvertedTime(inputDate).truncatedTo(ChronoUnit.DAYS));
		agendaStartTime = getAgendaStartDateTime();
		agendaEndTime = getAgendaEndDateTime();
	}
	
	/** Loads the task component to be displayed on the agenda. */
	public void addAllToAgenda(List<TaskComponent> taskList){
    	appointments().clear();
    	taskSet.clear();
    	for(TaskComponent t:taskList) taskSet.add(t.getTaskReference());
    	for(ReadOnlyTask task: taskSet) addAllOccurrencesInWeek(task);
    	
    }
	
	/** 
	 * Adds all occurrence of a particular task in current week into agenda.
	 * Typically used for daily tasks.
	 * Under the assumption that the task component list will not keep anything earlier than today.
	 */
	private void addAllOccurrencesInWeek(ReadOnlyTask task){
		
		//Ignore floating tasks
		if(task.getTaskType() == TaskType.FLOATING) return;
		//Ignore deadline tasks
		if(task.getTaskDateComponent().get(0).hasOnlyEndDate()) return;
		
		int i = 0; 
		List<TaskComponent> list = task.getTaskDateComponent();
		for(TaskComponent taskComponent: list){
			if(!isOutsideAgenda(taskComponent)){
				AppointmentImplLocal appointment = getAppointment(taskComponent);
				appointments().add(appointment);
			}
			if(list.size() - 1 == i){
				AppointmentImplLocal appointment = getAppointment(taskComponent);
				addCopiesToAgenda(taskComponent, appointment);
			}
			i++;
		}
	}
	
	/** Adds copies of future appointments to the future agenda based on recurring type.*/
	private void addCopiesToAgenda(TaskComponent taskComponent, AppointmentImplLocal appointment){
		switch(taskComponent.getTaskReference().getRecurringType()){
			case YEARLY:
				addYearlyOccurrences(appointment);
				break;
			case MONTHLY:
				addMonthlyOccurrences(appointment);
				break;
			case WEEKLY:
				addWeeklyOccurrences(appointment);
				break;
			case DAILY:
				addDailyOccurrences(appointment);
				break;
			default:
				break;				
		}
	}
	
	/** Returns an AppointmentImplLocal object from a task component */
	private AppointmentImplLocal getAppointment(TaskComponent taskComponent){
		
		AppointmentImplLocal appointment = new AppointmentImplLocal();
		appointment.setSummary(taskComponent.getTaskReference().getName().fullName);
		appointment.setDescription(taskComponent.getTaskReference().tagsString());
		appointment.setStartLocalDateTime(getConvertedTime(taskComponent.getStartDate()));			
		appointment.setEndLocalDateTime(getConvertedTime(taskComponent.getEndDate()));
		if(taskComponent.isArchived()){
			appointment.setAppointmentGroup(new Agenda.AppointmentGroupImpl().withStyleClass("archive"));			
		}else if(taskComponent.getTaskReference().getName().fullName.equals(BlockCommand.DUMMY_NAME)){
			appointment.setAppointmentGroup(new Agenda.AppointmentGroupImpl().withStyleClass("block"));
		}else{
			appointment.setAppointmentGroup(new Agenda.AppointmentGroupImpl().withStyleClass("normal"));
		}	
		return appointment;
			
	}

	/** Computes and adds all occurrences of this daily task to agenda.*/
	private void addDailyOccurrences(AppointmentImplLocal appointment) {
		if(isOutsideAgenda(appointment)) return;
		int dayOfWeek = appointment.getStartLocalDateTime().getDayOfWeek().getValue() % 7;
		if(appointment.getEndLocalDateTime().truncatedTo(ChronoUnit.DAYS).isBefore(agendaStartTime))
			dayOfWeek = 0;
		for(int i = dayOfWeek; i <= 6; i++){
			LocalDateTime start = getAppointmentStartTime(agendaStartTime.truncatedTo(ChronoUnit.DAYS),i,appointment);
			LocalDateTime end = getAppointmentEndTime(agendaStartTime.truncatedTo(ChronoUnit.DAYS),i,appointment);
			addToAgenda(appointment, start, end);
		}		
	}
		
	/** Computes and adds all occurrences of this weekly task to agenda.*/
	private void addWeeklyOccurrences(AppointmentImplLocal appointment) {
		if(isOutsideAgenda(appointment)) return;
		int dayOfWeek = appointment.getStartLocalDateTime().getDayOfWeek().getValue() % 7;
		LocalDateTime start = getAppointmentStartTime(agendaStartTime,dayOfWeek,appointment);
		LocalDateTime end = getAppointmentEndTime(agendaStartTime,dayOfWeek,appointment);
		addToAgenda(appointment, start, end);
	}
	
	/** Computes and adds all occurrences of this monthly task to agenda.*/
	private void addMonthlyOccurrences(AppointmentImplLocal appointment) {
		if(isOutsideAgenda(appointment)) return;
		int dayOffset = appointment.getStartLocalDateTime().getDayOfMonth() - agendaStartTime.getDayOfMonth();
			if(dayOffset < 0) dayOffset = 6 - (agendaEndTime.getDayOfMonth() - appointment.getStartLocalDateTime().getDayOfMonth());
		LocalDateTime start = getAppointmentStartTime(agendaStartTime.truncatedTo(ChronoUnit.DAYS),dayOffset,appointment);
		LocalDateTime end = getAppointmentEndTime(agendaStartTime.truncatedTo(ChronoUnit.DAYS),dayOffset,appointment);
		addToAgenda(appointment, start, end);
	}
	
	/** Computes and adds all occurrences of this yearly task to agenda.*/
	private void addYearlyOccurrences(AppointmentImplLocal appointment) {
		if(isOutsideAgenda(appointment)) return;
		if(appointment.getStartLocalDateTime().getDayOfYear() > agendaStartTime.getDayOfYear()+6
				||appointment.getStartLocalDateTime().getDayOfYear() < agendaStartTime.getDayOfYear()) return;
		int dayOffset  = appointment.getStartLocalDateTime().getDayOfYear() - agendaStartTime.getDayOfYear();
		LocalDateTime start = getAppointmentStartTime(agendaStartTime,dayOffset,appointment);
		LocalDateTime end = getAppointmentEndTime(agendaStartTime,dayOffset,appointment);
		addToAgenda(appointment, start, end);		
	}
	
	//================Utility methods================================================
	
	/** Returns a LocalDateTime object converted from TaskDate. */
	private LocalDateTime getConvertedTime(TaskDate t){
		return LocalDateTime.ofInstant(new Date(t.getDateInLong()).toInstant(), ZoneId.systemDefault());    	
    }
	
	/** Returns the startTime of the agenda. */
	private LocalDateTime getAgendaStartDateTime(){
		LocalDateTime displayedDateTime = getDisplayedLocalDateTime().truncatedTo(ChronoUnit.DAYS);
		int dayOfWeek = displayedDateTime.getDayOfWeek().getValue() % 7;
		return displayedDateTime.minusDays(dayOfWeek);
	}
	
	/** Returns the endTime of the agenda. */
	private LocalDateTime getAgendaEndDateTime(){
		LocalDateTime displayedDateTime = getDisplayedLocalDateTime().truncatedTo(ChronoUnit.DAYS);
		int dayOfWeek = displayedDateTime.getDayOfWeek().getValue() % 7;
		return displayedDateTime.plusDays(6 - dayOfWeek);
	}
	
	/** Returns the startTime of the appointment. */
	private LocalDateTime getAppointmentStartTime(LocalDateTime startPoint, int dayOffset, AppointmentImplLocal source){
		return startPoint.plusDays(dayOffset)
				.plusHours(source.getStartLocalDateTime().getHour())
				.plusMinutes(source.getStartLocalDateTime().getMinute());
	}
	
	/** Returns the endTime of the appointment. */
	private LocalDateTime getAppointmentEndTime(LocalDateTime startPoint, int dayOffset, AppointmentImplLocal source){
		return startPoint.plusDays(dayOffset)
				.plusHours(source.getEndLocalDateTime().getHour())
				.plusMinutes(source.getEndLocalDateTime().getMinute());
	}
	
	/** Returns a new appointment with start and end time specified and contains same data with source. */
	private AppointmentImplLocal copyAppointment(AppointmentImplLocal src, LocalDateTime start, LocalDateTime end){
		AppointmentImplLocal newOne = new AppointmentImplLocal().withAppointmentGroup(src.getAppointmentGroup())
				.withDescription(src.getDescription()).withSummary(src.getSummary());
		
		newOne.setStartLocalDateTime(start);
		newOne.setEndLocalDateTime(end);
		if(start.isAfter(src.getStartLocalDateTime()))
			newOne.setAppointmentGroup(new Agenda.AppointmentGroupImpl().withStyleClass("normal"));
		return newOne;
	}
	
	/** Adds a new appointment to agenda. */
	private void addToAgenda(AppointmentImplLocal appointment, LocalDateTime start, LocalDateTime end){
		AppointmentImplLocal newAppointment = copyAppointment(appointment, start, end);
		if(!appointments().contains(newAppointment) && !onSameDay(newAppointment, appointment))
			appointments().add(newAppointment);
	}
	
	/** Returns true if it is a future task that is not needed to add to agenda. */
	private boolean isOutsideAgenda(AppointmentImplLocal appointment){
		return appointment.getStartLocalDateTime().truncatedTo(ChronoUnit.DAYS).isAfter(agendaEndTime);
	}
	
	/** Returns true if it is a future task that is not needed to add to agenda. */
	private boolean isOutsideAgenda(TaskComponent taskComponent){
		return getConvertedTime(taskComponent.getStartDate()).truncatedTo(ChronoUnit.DAYS).isAfter(agendaEndTime)
				|| getConvertedTime(taskComponent.getEndDate()).truncatedTo(ChronoUnit.DAYS).isBefore(agendaStartTime);
	}
		
	/** Returns true if the appointments are on the same day. */
	private boolean onSameDay(AppointmentImplLocal src, AppointmentImplLocal toCheck){
		return src.getStartLocalDateTime().truncatedTo(ChronoUnit.DAYS).equals(toCheck.getStartLocalDateTime().truncatedTo(ChronoUnit.DAYS));
	}

}
```
###### \java\seedu\address\ui\NavbarPanel.java
``` java
    private void setEventHandlerForSelectionChangeEvent() {
        navbarView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
            	logger.fine("Selection in navigation bar panel changed to : '" + newValue + "'");
                raise(new NavigationSelectionChangedEvent(newValue));
            }
        });
    }
    
    public void scrollTo(int index) {
        Platform.runLater(() -> {
        	navbarView.scrollTo(index);
        	navbarView.getSelectionModel().clearAndSelect(index);
        });
    }
    
```
###### \java\seedu\address\ui\NavbarPanel.java
``` java
    public String getNavigationCommand(String navigation){
    	switch(navigation){
    		
    		case NAVBAR_DEADLINES:
    			day = new Date(System.currentTimeMillis()+24*60*60*1000);
    			command = FindCommand.COMMAND_WORD +" by "+ formatter.format(day) + " 12am";
    			return command;
    		case NAVBAR_INCOMING_DEADLINES:
    			day = new Date(System.currentTimeMillis()+24*8*60*60*1000);
    			command = FindCommand.COMMAND_WORD +" by "+ formatter.format(day) + " 12am";
    			return command;
    		case NAVBAR_FLOATING_TASKS:
    			command = FindCommand.COMMAND_WORD +" -F";
    			return command;
    		case NAVBAR_COMPLETED:
    			command = FindCommand.COMMAND_WORD +" -C";
    			return command;
    		default:
    			return ListCommand.COMMAND_WORD;
    	}    	  
	}
    
    
    
    
    class NavbarViewCell extends ListCell<String> {
    	
    	public NavbarViewCell() {
    	}
    	
    	@Override
        protected void updateItem(String li, boolean empty) {
            super.updateItem(li, empty);

            if (empty || li == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(NavbarCard.load(li).getLayout());
            }
        }
    }
}
```
###### \java\seedu\address\ui\TaskCard.java
``` java
    private void initializeDate() {
    	if (dateComponent.getStartDate().getDateInLong() == TaskDate.DATE_NOT_PRESENT) {
            startDate.setText("");
        } else {
            startDate.setText(dateComponent.getStartDate().getFormattedDate());
        }
    	
    	if (dateComponent.getEndDate().getDateInLong() == TaskDate.DATE_NOT_PRESENT) {
            endDate.setText("");
        } else {
        	endDate.setText(dateComponent.getEndDate().getFormattedDate());
        }
    }
    
    /** Sets cell color for the task list. Style the css here to prevent overriding. */
    private void setCellColor(){   	
    	//normal non-floating task
    	cardPane.setStyle("-fx-background-color : rgba(110, 196, 219, 0.3);");
    	//Deadline
    	if(dateComponent.hasOnlyEndDate())
    		cardPane.setStyle("-fx-background-color : rgba(250, 124, 146, 0.3);");
    	//Floating task
    	if(task.getTaskType() == TaskType.FLOATING)
    		cardPane.setStyle("-fx-background-color : rgba(255, 247, 192, 0.3);");
    	//Blocked Slot
    	if(task.getName().fullName.equals("BLOCKED SLOT"))
    		cardPane.setStyle("-fx-background-color : rgba(148, 93, 96, 0.3);");
    	//Completed
    	if(dateComponent.isArchived()){
    		cardPane.setStyle("-fx-background-color : rgba(102,171,140,0.3);");
    		name.setStyle("-fx-text-fill : derive(#373737, 20%);");
    		id.setStyle("-fx-text-fill : derive(#373737, 20%);");
    		startDate.setStyle("-fx-text-fill : derive(#373737, 20%);");
    		endDate.setStyle("-fx-text-fill : derive(#373737, 20%);");
    		recurringType.setStyle("-fx-text-fill : derive(#373737, 20%);");
    	}  	
    }

    public HBox getLayout() {    	
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox)node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \java\seedu\address\ui\UiManager.java
``` java
    @Subscribe
    private void handleNavigationSelectionChangedEvent(NavigationSelectionChangedEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getCommandBox().handleNavigationChanged(mainWindow.getNavbarPanel().getNavigationCommand(event.getNewSelection()));
    }
    
    @Subscribe
    private void handleTaskListChangedEvent(TaskListChangedEvent event){
    	logger.info(LogsCenter.getEventHandlingLogMessage(event));
    	mainWindow.getBrowserPanel().reloadAgenda(event.data.getTaskComponentList());
    }
    
    @Subscribe
    private void handleAgendaTimeRangeChangedEvent(AgendaTimeRangeChangedEvent event){
    	logger.info(LogsCenter.getEventHandlingLogMessage(event));
    	mainWindow.getBrowserPanel().updateAgenda(event.getInputDate(), event.getData());
    }

}
```
###### \resources\view\BrowserPanel.fxml
``` fxml
<VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.BrowserPanel" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
	<children>
		<MyAgenda id="agenda" fx:id="agenda">
		</MyAgenda>
	</children>
</VBox>

```
###### \resources\view\MainWindow.fxml
``` fxml
<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="1010.0" prefWidth="1210.0" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.MainWindow">
   <stylesheets>     
      <URL value="@Extensions.css" />
   </stylesheets>
   <children>
      <MenuBar VBox.vgrow="NEVER">
         <menus>
            <Menu mnemonicParsing="false" text="File">
               <items>
                  <MenuItem mnemonicParsing="false" onAction="#handleExit" text="Exit" />
               </items>
            </Menu>
            <Menu mnemonicParsing="false" text="Help">
               <items>
                  <MenuItem fx:id="helpMenuItem" mnemonicParsing="false" onAction="#handleHelp" text="Help" />
               </items>
            </Menu>
            <Menu mnemonicParsing="false" text="Customize Skin">
               <items>
                  <MenuItem mnemonicParsing="false" onAction="#handleCustomize" text="I'm feeling lucky!" />
               </items>
            </Menu>
         </menus>
      </MenuBar>
      <SplitPane id="splitPane" fx:id="splitPane" dividerPositions="0.4" VBox.vgrow="ALWAYS">
      	<items>
      		<VBox fx:id="navbar" minWidth="300" prefWidth="300">
         		<padding>
         			<Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
         		</padding>
         		<children>
         			<AnchorPane fx:id="navbarPanelPlaceholder" VBox.vgrow="ALWAYS" />
         		</children>
      		</VBox>
      		<AnchorPane>
         <children>
         			<AnchorPane fx:id="commandBoxPlaceholder" minHeight="60.0" minWidth="870.0" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
            			<padding>
               			<Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
            			</padding>
         			</AnchorPane>
         			<AnchorPane fx:id="resultDisplayPlaceholder" layoutY="60.0" maxHeight="60.0" minHeight="90.0" minWidth="870.0" prefHeight="60.0" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
           				<padding>
               				<Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
           				</padding>
       				</AnchorPane>
         			<SplitPane id="splitPane" fx:id="splitPane" dividerPositions="0.4" layoutY="170.0" minHeight="560.0" prefWidth="870.0" VBox.vgrow="ALWAYS">
            			<items>
               			<VBox fx:id="taskList" minWidth="100" prefWidth="430">
                   			<padding>
                       			<Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                   			</padding>
                  				<children>
                     				<AnchorPane fx:id="taskListPanelPlaceholder" VBox.vgrow="ALWAYS" />
                  				</children>
               			</VBox>
               			<AnchorPane fx:id="browserPlaceholder" minWidth="100" maxWidth = "Infinity">
                   			<padding>
                       			<Insets bottom="10" left="10" right="10" top="10" />
                   			</padding>
               			</AnchorPane>
            			</items>
         			</SplitPane>
         </children>
      		</AnchorPane>
      	</items>
      	</SplitPane>
      	
      	<AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="NEVER" />
   </children>
</VBox>
```
