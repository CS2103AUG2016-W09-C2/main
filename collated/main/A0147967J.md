# A0147967J
###### \java\seedu\address\commons\events\model\FilePathChangeEvent.java
``` java
/** Indicates the file path of the task master should change. */
public class FilePathChangeEvent extends BaseEvent {

    public final String newFilePath;

    public FilePathChangeEvent(String newFilePath) {
        this.newFilePath = newFilePath;
    }

    @Override
    public String toString() {
        return "File path changes to :" + newFilePath;
    }
}
```
###### \java\seedu\address\commons\events\ui\AgendaTimeRangeChangedEvent.java
``` java
/**
 * Indicates a change in the displayed time range of the agenda.
 */
public class AgendaTimeRangeChangedEvent extends BaseEvent {

    private final TaskDate inputDate;
    private final List<TaskOccurrence> taskComponentList;

    public AgendaTimeRangeChangedEvent(TaskDate inputDate, List<TaskOccurrence> list) {
        this.inputDate = inputDate;
        this.taskComponentList = list;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public TaskDate getInputDate() {
        return inputDate;
    }
    
    public List<TaskOccurrence> getData() {
        return taskComponentList;
    }
}
```
###### \java\seedu\address\commons\events\ui\FailedCommandAttemptedEvent.java
``` java
/**
 * Indicates an attempt to execute a failed command
 */
public class FailedCommandAttemptedEvent extends BaseEvent {

    public FailedCommandAttemptedEvent(Command command) {
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\address\commons\events\ui\NavigationSelectionChangedEvent.java
``` java
/**
 * Represents a selection change in the Navigation Bar Panel
 */
public class NavigationSelectionChangedEvent extends BaseEvent {

    private final String newSelection;

    public NavigationSelectionChangedEvent(String newSelection) {
        this.newSelection = newSelection;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public String getNewSelection() {
        return newSelection;
    }
}
```
###### \java\seedu\address\logic\commands\BlockCommand.java
``` java
/**
 * Blocks a certain time slot in the task list.
 */
public class BlockCommand extends Command {

    public static final String COMMAND_WORD = "block";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Blocks a certain time slot in the schedule. "
            + "Parameters: TASK_NAME [t/TAG]...\n" + "Example: " + COMMAND_WORD
            + " from 2 oct 2am to 2 oct 3am t/highPriority";

    public static final String MESSAGE_SUCCESS = "Timeslot blocked: %1$s";
    public static final String MESSAGE_TIMESLOT_OCCUPIED = "This timeslot is already blocked or overlapped with existing tasks.";
    public static final String MESSAGE_ILLEGAL_TIME_SLOT = "End time must be later than Start time.";
    public static final String DUMMY_NAME = "BLOCKED SLOT";

    private final Task toBlock;

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     */
    public BlockCommand(Set<String> tags, TaskDate startDate, TaskDate endDate) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toBlock = new Task(new Name(DUMMY_NAME), new UniqueTagList(tagSet), new TaskDate(startDate),
                new TaskDate(endDate), RecurringType.NONE, Task.NO_RECURRING_PERIOD);
        if (!this.toBlock.getLastAppendedComponent().isValidTimeSlot()) {
            indicateAttemptToExecuteIncorrectCommand();
            throw new IllegalValueException(MESSAGE_ILLEGAL_TIME_SLOT);
        }
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addTask(toBlock);
            CommandResult result = new CommandResult(String.format(MESSAGE_SUCCESS, toBlock));
            int targetIndex = model.getFilteredTaskComponentList().size();
            EventsCenter.getInstance().post(new JumpToListRequestEvent(targetIndex - 1));
            return result;
        } catch (TimeslotOverlapException e) {
            indicateAttemptToExecuteFailedCommand();
            urManager.popFromUndoQueue();
            return new CommandResult(MESSAGE_TIMESLOT_OCCUPIED);
        } catch (DuplicateTaskException e) {
            assert false : "not applicable for block command";
            return new CommandResult(MESSAGE_TIMESLOT_OCCUPIED);
        }

    }

}
```
###### \java\seedu\address\logic\commands\ChangeDirectoryCommand.java
``` java
/**
 * Changes the file path of the file and exports all existing data to the
 * specified file.
 */
public class ChangeDirectoryCommand extends Command {

    public static final String COMMAND_WORD = "cd";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Changes the directory for the tasklist."
            + "Parameters: FILE_PATH\n" + "Example: " + COMMAND_WORD + " D:\t.xml";

    public static final String MESSAGE_SUCCESS = "Alert: This operation is irreversible.\nFile path successfully changed to : %1$s";
    public static final String MESSAGE_IO_ERROR = "Error when saving/reading file...";
    public static final String MESSAGE_CONVENSION_ERROR = "Wrong file type/Invalid file path detected.";

    private final String filePath;

    public ChangeDirectoryCommand(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public CommandResult execute() {
        try {
            if (!filePath.endsWith(".xml"))
                throw new DataConversionException(null);
            XmlTaskListStorage newFile = new XmlTaskListStorage(filePath);
            newFile.saveTaskList(model.getTaskMaster(), filePath);
            model.changeDirectory(filePath);
            Config config = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE).get();
            config.setTaskListFilePath(filePath);
            ConfigUtil.saveConfig(config, Config.DEFAULT_CONFIG_FILE);
            urManager.resetQueue();
            return new CommandResult(String.format(MESSAGE_SUCCESS, filePath));
        } catch (DataConversionException dce) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_CONVENSION_ERROR);
        } catch (IOException ioe) {
            indicateAttemptToExecuteFailedCommand();
            return new CommandResult(MESSAGE_IO_ERROR);
        }
    }

}
```
###### \java\seedu\address\logic\commands\Command.java
``` java
    /**
     * Assigns an undo/redo manager to the command to manage undo/redo
     * operation.
     */
    public void assignManager(UndoRedoManager urManager) {
        this.urManager = urManager;
    }

    /**
     * Raises an event to indicate an attempt to execute a failed command
     */
    protected void indicateAttemptToExecuteFailedCommand() {
        EventsCenter.getInstance().post(new FailedCommandAttemptedEvent(this));
    }
}
```
###### \java\seedu\address\logic\commands\CompleteCommand.java
``` java
/**
 * Marks a task as done identified using it's last displayed index from the task
 * list.
 */
public class CompleteCommand extends Command {

    public static final String COMMAND_WORD = "done";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Archives the task identified by the index number used in the last task listing. The Task will be deleted after exiting the app.\n"
            + "Parameters: INDEX (must be a positive integer)\n" + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_COMPLETE_TASK_SUCCESS = "Completed Task: %1$s";

    public final int targetIndex;

    public CompleteCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<TaskOccurrence> lastShownList = model.getFilteredTaskComponentList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            urManager.popFromUndoQueue();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        TaskOccurrence taskToDelete = lastShownList.get(targetIndex - 1);

        try {
            model.archiveTask(taskToDelete);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }

        return new CommandResult(String.format(MESSAGE_COMPLETE_TASK_SUCCESS, taskToDelete.getTaskReference()));
    }
}
```
###### \java\seedu\address\logic\commands\RedoCommand.java
``` java
/**
 * Redos the previous redoable operation.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "r";

    public static final String MESSAGE_FAIL = "No command to redo.";

    public RedoCommand() {
    }

    @Override
    public CommandResult execute() {

        try {
            Context contextToRedo = urManager.getContextToRedo();
            urManager.addToUndoQueueUsedByRedo(model, contextToRedo.getCommand());
            return contextToRedo.getCommand().execute();
        } catch (NoAvailableCommandException nace) {
            indicateAttemptToExecuteFailedCommand();
            return new CommandResult(MESSAGE_FAIL);
        }
    }
}
```
###### \java\seedu\address\logic\commands\UndoCommand.java
``` java
/**
 * Undos the previous undoable operation.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "u";
    public static final String MESSAGE_SUCCESS = "Undo successfully.";
    public static final String MESSAGE_FAIL = "No command to undo.";

    public UndoCommand() {
    }

    @Override
    public CommandResult execute() {

        try {
            Context contextToUndo = urManager.getContextToUndo();
            
            model.resetData(contextToUndo.getData()); // resets the data
            
            if(contextToUndo.getCommand() instanceof FindCommand 
               || contextToUndo.getCommand() instanceof ListCommand) {
                // resets the filtered list if needed
                model.updateFilteredTaskList(contextToUndo.getPreviousExpression());
            }
            
            if(contextToUndo.getCommand() instanceof ViewCommand) {
                //resets the agenda if needed
                EventsCenter.getInstance().post(new AgendaTimeRangeChangedEvent(contextToUndo.previousTime, model.getTaskMaster().getTaskOccurrenceList()));
            }
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (NoAvailableCommandException nace) {
            indicateAttemptToExecuteFailedCommand();
            return new CommandResult(MESSAGE_FAIL);
        }
    }

}
```
###### \java\seedu\address\logic\commands\ViewCommand.java
``` java
/**
 * Views the agenda for the week specified by (contains) input date.
 */
public class ViewCommand extends Command {

    public final TaskDate inputDate;

    private SimpleDateFormat formatter = new SimpleDateFormat("yyyy MMM dd, EEE");

    public static final String COMMAND_WORD = "view";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": View the agenda of the week specified by input date.\n"
            + "Parameters: DATE_TIME \n" + "Example: " + COMMAND_WORD + " next WednesDay";

    public static final String MESSAGE_UPDATE_AGENDA_SUCCESS = "Agenda Updated to Week specified by: %1$s";

    public ViewCommand(TaskDate inputDate) {
        this.inputDate = inputDate;
    }

    @Override
    public CommandResult execute() {

        EventsCenter.getInstance()
                .post(new AgendaTimeRangeChangedEvent(inputDate, model.getTaskMaster().getTaskOccurrenceList()));
        return new CommandResult(String.format(MESSAGE_UPDATE_AGENDA_SUCCESS, formatter.format(inputDate.getDate())));

    }

}
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
    private Command prepareBlock(String args) {
        Matcher matcher = BLOCK_DATA_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, BlockCommand.MESSAGE_USAGE));
        }
        try {

            String startInput = matcher.group("startTime");
            String endInput = matcher.group("endTime");

            return new BlockCommand(getTagsFromArgs(matcher.group("tagArguments")),
                    new TaskDate(DateParser.getInstance().getDateFromString(startInput).getTime()),
                    new TaskDate(DateParser.getInstance().getDateFromString(endInput).getTime()));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the complete task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareComplete(String args) {

        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
        }

        return new CompleteCommand(index.get());
    }
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
    /**
     * Returns the view command with input date parsed
     * 
     * @param arguments
     *            passed by user
     * @return prepared view command
     */
    private Command prepareView(String arguments) {
        // TODO Auto-generated method stub
        Date date;
        try {
            date = DateParser.getInstance().getDateFromString(arguments);
            date = DateFormatterUtil.getStartOfDay(date);
        } catch (IllegalValueException e) {
            return new IncorrectCommand(e.getMessage());
        }
        return new ViewCommand(new TaskDate(date));
    }
```
###### \java\seedu\address\logic\UndoRedoManager.java
``` java
/**
 * Stores and provides context for undo/redo operations.
 */
public class UndoRedoManager {

    private ArrayDeque<Context> undoQueue;
    private ArrayDeque<Context> redoQueue;

    /** Arbitrarily chosen number to ensure overall performance. */
    private final int MAX_TIMES = 3;

    public UndoRedoManager() {
        undoQueue = new ArrayDeque<Context>();
        redoQueue = new ArrayDeque<Context>();
    }

    /**
     * Adds the command to undo queue for LogicManager.
     */
    public void addToUndoQueue(Model model, Command command) {
        if (!isUndoable(command))
            return;
        if (isIgnored(command)) {
            return;
        }
        if (undoQueue.size() == MAX_TIMES) {
            undoQueue.removeFirst();
        }
        undoQueue.addLast(new Context(model, command));
        redoQueue.clear();

    }

    /**
     * Pops the failed or incorrect (but not detected during parsing) command
     * from undo queue
     */
    public void popFromUndoQueue() {
        undoQueue.removeLast();
    }

    /**
     * Change Directory command succeeds, clear all undo and redo queue.
     */
    public void resetQueue() {
        undoQueue.clear();
        redoQueue.clear();
    }

    /**
     * Adds the command to undo queue for redo command.
     */
    public void addToUndoQueueUsedByRedo(Model model, Command command) {
        if (!isUndoable(command)) {
            undoQueue.clear();
            redoQueue.clear();
            return;
        }
        if (isIgnored(command)) {
            return;
        }
        if (undoQueue.size() == MAX_TIMES) {
            undoQueue.removeFirst();
        }
        undoQueue.addLast(new Context(model, command));

    }

    public Context getContextToUndo() throws NoAvailableCommandException {
        try {
            Context contextToUndo = undoQueue.removeLast();
            redoQueue.addLast(contextToUndo);
            return contextToUndo;
        } catch (Exception e) {
            throw new NoAvailableCommandException();
        }
    }

    public Context getContextToRedo() throws NoAvailableCommandException {
        try {
            Context contextToRedo = redoQueue.removeLast();
            undoQueue.addLast(contextToRedo);
            return contextToRedo;
        } catch (Exception e) {
            throw new NoAvailableCommandException();
        }
    }

    /**
     * Returns true if the command does not need to be added in undo/redo queue.
     */
    public Boolean isIgnored(Command command) {
        return command instanceof RedoCommand || command instanceof UndoCommand 
                || command instanceof IncorrectCommand;
    }

    /**
     * Returns true if the command is undoable. Currently, only
     * ChangeDirectoryCommand is undoable.
     */
    public Boolean isUndoable(Command command) {
        return !(command instanceof ChangeDirectoryCommand);
    }

    // =================================================================
    public class NoAvailableCommandException extends Exception {
    }

    /**
     * Inner class for backup previous data and commands.
     */
    public class Context {

        private ReadOnlyTaskMaster taskList;
        private Command command;
        private Expression previousExpression;
        public TaskDate previousTime;

        Context(Model model, Command command) {
            this.command = command;
            this.taskList = new TaskMaster(model.getTaskMaster());
            this.previousExpression = model.getPreviousExpression();
            this.previousTime = model.getPreviousDate();
        }

        public Command getCommand() {
            return command;
        }

        public ReadOnlyTaskMaster getData() {
            return taskList;
        }
        
        public Expression getPreviousExpression(){
            return previousExpression;
        }
    }
}
```
###### \java\seedu\address\model\Model.java
``` java
	/** Returns previous filtering expression. */
	Expression getPreviousExpression();
	
	/** Updates(Resets) the filtered list with given expression.*/
    void updateFilteredTaskList(Expression expression);
    
    /** Updates the file path for current storage manager of the model.*/
    void changeDirectory(String filePath);
    
    /** Archives the given task component. */
    void archiveTask(TaskOccurrence target) throws TaskNotFoundException;
    
    /** Returns current system time.*/
    TaskDate getPreviousDate();
    
    /** Sets the system time. */
    void setSystemTime(AgendaTimeRangeChangedEvent atrce);

}
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public synchronized void archiveTask(TaskOccurrence target) throws TaskNotFoundException {
        taskMaster.archiveTask(target);
        RecurringTaskManager.getInstance().updateRecurringTasks(target);
        indicateTaskListChanged();
        updateFilteredTaskList(previousExpression);
        
    }

    @Override
    public void changeDirectory(String filePath) {
        raise(new FilePathChangeEvent(filePath));
    }
```
###### \java\seedu\address\model\ModelManager.java
``` java
    private class InitialQualifier implements Qualifier {

        @Override
        public boolean run(TaskOccurrence task) {
            return true;
        }
        
    }
    
    private class TypeQualifier implements Qualifier {
        private TaskType typeKeyWords;

        TypeQualifier(TaskType typeKeyWords) {
            this.typeKeyWords = typeKeyWords;
        }

        @Override
        public boolean run(TaskOccurrence task) {
            return task.getTaskReference().getTaskType().equals(typeKeyWords) && !task.isArchived();
        }

    }
    
```
###### \java\seedu\address\model\task\Task.java
``` java
    public void setRecurringDates(List<TaskOccurrence> newComponentList) {
        this.recurringDates = newComponentList;
    }

```
###### \java\seedu\address\model\task\UniqueTaskList.java
``` java
    /**
     * Signals that an operation adding/blocking a time slot in the list would
     * fail because the timeslot is already occupied.
     */

    public static class TimeslotOverlapException extends DuplicateDataException {

        public TimeslotOverlapException() {
            super("Operation cannot be done due to overlapping with blocked slots.");
        }
    }
```
###### \java\seedu\address\model\task\UniqueTaskList.java
``` java
    /**
     * Returns true if the given task requests to use a blocked time slot.
     */
    public boolean overlaps(ReadOnlyTask toCheck) {
        assert toCheck != null;
        // ignore floating and deadline tasks
        if (toCheck.getLastAppendedComponent().getStartDate().getDateInLong() == TaskDate.DATE_NOT_PRESENT)
            return false;

        // Only compare tasks with blocked time slots.
        // Or if it is block command, check with existing tasks
        return isOverlappingWithBlock(toCheck) || isBlockOverlappingWithTask(toCheck);

    }

    public boolean isBlockOverlappingWithTask(ReadOnlyTask toCheck) {
        if (!toCheck.getName().fullName.equals(BlockCommand.DUMMY_NAME)) {
            return false;
        }
        for (Task t : internalList) {
            if (t.getTaskType() == TaskType.NON_FLOATING && !t.getLastAppendedComponent().hasOnlyEndDate()
                    && isWithinSlot(toCheck, t)) {
                return true;
            }
        }

        return false;
    }

    public boolean isOverlappingWithBlock(ReadOnlyTask toCheck) {
        for (Task t : internalList) {
            if (t.getName().fullName.equals(BlockCommand.DUMMY_NAME) && isWithinSlot(toCheck, t)) {
                return true;
            }
        }
        return false;
    }

    /** Returns true if the toCheck slot overlaps with the given one. */
    public boolean isWithinSlot(ReadOnlyTask toCheck, ReadOnlyTask given) {
        return !(!given.getLastAppendedComponent().getEndDate().getDate()
                .after(toCheck.getLastAppendedComponent().getStartDate().getDate())
                || !given.getLastAppendedComponent().getStartDate().getDate()
                        .before(toCheck.getLastAppendedComponent().getEndDate().getDate()));
    }
```
###### \java\seedu\address\model\task\UniqueTaskList.java
``` java
    /**
     * Returns true if the specified task component is successfully archived.
     */
    public boolean archive(TaskOccurrence target) {
        assert target != null;
        if (target.isArchived() == true) {
            return false;
        }
        boolean taskFoundAndArchived = false;
        System.out.println(internalOccurrenceList.contains(target));
        for (TaskOccurrence t : internalOccurrenceList) {
            if (t.equals(target)) {
                t.archive();
                taskFoundAndArchived = true;
                t.getTaskReference().completeTaskWhenAllOccurrencesArchived();
            }
        }
        return taskFoundAndArchived;
    }
    
    //Bad SLAP, needs improvement
    public boolean overlapsForEdit(TaskOccurrence original, TaskOccurrence toCheck){
        for(TaskOccurrence t: internalOccurrenceList){
            if(!t.equals(original) && t.getTaskReference().getName().fullName.equals(BlockCommand.DUMMY_NAME)){
                if(!(!t.getEndDate().getDate()
                        .after(toCheck.getStartDate().getDate())
                        || !t.getStartDate().getDate()
                                .before(toCheck.getEndDate().getDate()))) return true;
            }
        }
        return false;
    }
    
```
###### \java\seedu\address\model\TaskMaster.java
``` java
    public void resetData(Collection<? extends ReadOnlyTask> newTasks,
            Collection<? extends TaskOccurrence> newComponents, Collection<Tag> newTags) {
        setTasks(newTasks.stream().map(Task::new).collect(Collectors.toList()));
        rebuildComponentList();
        setTags(newTags);
    }

    /**
     * Rebuilds the component list based on restored tasks, as copy constructor
     * of task component does not work.
     */
    public void rebuildComponentList() {
        this.tasks.getInternalOccurrenceList().clear();
        ArrayList<TaskOccurrence> fullList = new ArrayList<TaskOccurrence>();
        for (Task task : tasks.getInternalTaskList()) {
            ArrayList<TaskOccurrence> newList = new ArrayList<TaskOccurrence>();
            for (TaskOccurrence c : task.getTaskDateComponent()) {
                TaskDate startDate = c.getStartDate();
                TaskDate endDate = c.getEndDate();
                boolean isArchived = c.isArchived();
                TaskOccurrence newTaskComponent = new TaskOccurrence(task, startDate, endDate);
                if (isArchived)
                    newTaskComponent.archive();
                newList.add(newTaskComponent);
                fullList.add(newTaskComponent);
            }
            task.setRecurringDates(newList);
        }
        this.tasks.getInternalOccurrenceList().setAll(fullList);
    }

```
###### \java\seedu\address\model\TaskMaster.java
``` java
    public boolean archiveTask(TaskOccurrence target) throws TaskNotFoundException {
        // TODO Auto-generated method stub
        if (tasks.archive(target)) {
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }
```
###### \java\seedu\address\storage\StorageManager.java
``` java
    @Override
    @Subscribe
    public void handleFilePathChangeEvent(FilePathChangeEvent event){
    	logger.info(LogsCenter.getEventHandlingLogMessage(event, "File path changed"));
    	taskListStorage.setTaskListFilePath(event.newFilePath);
    	
    }

}
```
###### \java\seedu\address\ui\BrowserPanel.java
``` java
    private void initialize(ObservableList<TaskOccurrence> taskList) {
        agenda.setDisplayedDateTime(new TaskDate(new Date(System.currentTimeMillis())));
        loadTaskList(taskList);
    }

    public void loadTaskPage(ReadOnlyTask task) {
        // Deprecated method
    }

    public void updateAgenda(TaskDate inputDate, List<TaskOccurrence> taskList) {
        agenda.setDisplayedDateTime(inputDate);
        loadTaskList(taskList);
    }

    public void reloadAgenda(List<TaskOccurrence> taskList) {
        loadTaskList(taskList);
    }

    /**
     * Frees resources allocated to the browser.
     */
    public void freeResources() {
        agenda = null;
    }

    public void loadTaskList(List<TaskOccurrence> taskList) {
        agenda.addAllToAgenda(taskList);
    }

}
```
###### \java\seedu\address\ui\CommandBox.java
``` java
    @Subscribe
    private void handleFailedCommandAttempted(FailedCommandAttemptedEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(event,"Failed command: " + previousCommandTest +"\n"));
        setStyleToIndicateFailedCommand();
        restoreCommandText();
    }
```
###### \java\seedu\address\ui\CommandBox.java
``` java
    /**
     * Sets the command box style to indicate a failed attempt
     */
    private void setStyleToIndicateFailedCommand() {
        getStyleClass().add("fail");
    }
```
###### \java\seedu\address\ui\MyAgenda.java
``` java
/**
 * This class is modified from jfxtras agenda for Happy Jim Task Master Use.
 */
public class MyAgenda extends Agenda {

    /** Keeps track of the start and end time of agenda. */
    private LocalDateTime agendaStartTime;
    private LocalDateTime agendaEndTime;

    /** Constructor */
    public MyAgenda() {

        super();

        /** Sets preferred size */
        setPrefSize(760, 570);

        /** Sets css class. */
        this.getStyleClass().add(MyAgenda.class.getSimpleName());

        /**
         * Disables dragging and resizing appointments. The agenda is only used
         * as a visualization.
         */
        allowDraggingProperty().set(false);
        allowResizeProperty().set(false);

        /** Disables editing via agenda */
        setEditAppointmentCallback((Callback<Appointment, Void>) (appointment) -> {
            return null;
        });

        /** Sets the locale used by calendar. */
        setLocale(Locale.ENGLISH);

        /** Computes and sets value for variables */
        agendaStartTime = getAgendaStartDateTime();
        agendaEndTime = getAgendaEndDateTime();

    }

    // =================For change agenda
    // range================================================

    /** Sets the displayed date time of the agenda to specified one. */
    public void setDisplayedDateTime(TaskDate inputDate) {
        displayedLocalDateTime().set(getConvertedTime(inputDate).truncatedTo(ChronoUnit.DAYS));
        agendaStartTime = getAgendaStartDateTime();
        agendaEndTime = getAgendaEndDateTime();
    }

    /** Loads the task component to be displayed on the agenda. */
    public void addAllToAgenda(List<TaskOccurrence> taskList) {
        appointments().clear();
        for (TaskOccurrence t : taskList){
            addAllOccurrencesInWeek(t);
        }
    }

    /**
     * Adds all occurrence of a particular task in current week into agenda.
     * Typically used for daily tasks. Under the assumption that the task
     * component list will not keep anything earlier than today.
     */
    private void addAllOccurrencesInWeek(TaskOccurrence taskOccurrence) {

        //Only cares time slot
        if(!taskOccurrence.isSlot()) {
            return;
        }

        if (!isOutsideAgenda(taskOccurrence)) {
            AppointmentImplLocal appointment = getAppointment(taskOccurrence);
            appointments().add(appointment);
        }
        if (taskOccurrence.equals(taskOccurrence.getTaskReference().getLastAppendedComponent())) {
            AppointmentImplLocal appointment = getAppointment(taskOccurrence);
            addCopiesToAgenda(taskOccurrence, appointment);
        }

    }

    /**
     * Adds copies of future appointments to the future agenda based on
     * recurring type.
     */
    private void addCopiesToAgenda(TaskOccurrence taskOccurrence, AppointmentImplLocal appointment) {
        if (isOutsideAgenda(appointment)) {
            return;
        }
        switch (taskOccurrence.getTaskReference().getRecurringType()) {
        case YEARLY:
            addYearlyOccurrences(appointment, getEndBoundary(taskOccurrence, appointment));
            break;
        case MONTHLY:
            addMonthlyOccurrences(appointment, getEndBoundary(taskOccurrence, appointment));
            break;
        case WEEKLY:
            addWeeklyOccurrences(appointment, getEndBoundary(taskOccurrence, appointment));
            break;
        case DAILY:
            addDailyOccurrences(appointment, getEndBoundary(taskOccurrence, appointment));
            break;
        default:
            break;
        }
    }
    
    /**
     * Adds copies of future appointments to the future agenda based on
     * recurring type.
     */
    private LocalDateTime getEndBoundary(TaskOccurrence taskOccurrence, AppointmentImplLocal appointment) {
        LocalDateTime endBoundary = null;
        int recurringCount = taskOccurrence.getTaskReference().getRecurringPeriod();
        if(recurringCount >= 0){
            switch (taskOccurrence.getTaskReference().getRecurringType()) {
            case YEARLY:
                endBoundary = appointment.getStartLocalDateTime().plusYears(recurringCount);
                break;
            case MONTHLY:
                endBoundary = appointment.getStartLocalDateTime().plusMonths(recurringCount);
                break;
            case WEEKLY:
                endBoundary = appointment.getStartLocalDateTime().plusWeeks(recurringCount);
                break;
            case DAILY:
                endBoundary = appointment.getStartLocalDateTime().plusDays(recurringCount);
                break;
            default:
                break;
            }
        }
        return endBoundary;
    }

    /** Returns an AppointmentImplLocal object from a task component */
    private AppointmentImplLocal getAppointment(TaskOccurrence taskOccurrence) {

        AppointmentImplLocal appointment = new AppointmentImplLocal();
        appointment.setSummary(taskOccurrence.getTaskReference().getName().fullName);
        appointment.setDescription(taskOccurrence.getTaskReference().tagsString());
        appointment.setStartLocalDateTime(getConvertedTime(taskOccurrence.getStartDate()));
        appointment.setEndLocalDateTime(getConvertedTime(taskOccurrence.getEndDate()));
        if (taskOccurrence.isArchived()) {
            appointment.setAppointmentGroup(new Agenda.AppointmentGroupImpl().withStyleClass("archive"));
        } else if (taskOccurrence.getTaskReference().getName().fullName.equals(BlockCommand.DUMMY_NAME)) {
            appointment.setAppointmentGroup(new Agenda.AppointmentGroupImpl().withStyleClass("block"));
        } else {
            appointment.setAppointmentGroup(new Agenda.AppointmentGroupImpl().withStyleClass("normal"));
        }
        return appointment;

    }

    /** Computes and adds all occurrences of this daily task to agenda. */
    private void addDailyOccurrences(AppointmentImplLocal appointment, LocalDateTime endBoundary) {
        int dayOfWeek = appointment.getStartLocalDateTime().getDayOfWeek().getValue() % 7;
        if (appointment.getEndLocalDateTime().truncatedTo(ChronoUnit.DAYS).isBefore(agendaStartTime)) {
            dayOfWeek = 0;
        }
        for (int i = dayOfWeek; i <= 6; i++) {
            LocalDateTime start = getAppointmentStartTime(agendaStartTime.truncatedTo(ChronoUnit.DAYS), i, appointment);
            LocalDateTime end = getAppointmentEndTime(agendaStartTime.truncatedTo(ChronoUnit.DAYS), i, appointment);
            addToAgenda(appointment, start, end, endBoundary);
        }
    }

    /** Computes and adds all occurrences of this weekly task to agenda. */
    private void addWeeklyOccurrences(AppointmentImplLocal appointment ,LocalDateTime endBoundary) {
        int dayOfWeek = appointment.getStartLocalDateTime().getDayOfWeek().getValue() % 7;
        LocalDateTime start = getAppointmentStartTime(agendaStartTime, dayOfWeek, appointment);
        LocalDateTime end = getAppointmentEndTime(agendaStartTime, dayOfWeek, appointment);
        addToAgenda(appointment, start, end, endBoundary);
    }

    /** Computes and adds all occurrences of this monthly task to agenda. */
    private void addMonthlyOccurrences(AppointmentImplLocal appointment, LocalDateTime endBoundary) {
        int dayOffset = appointment.getStartLocalDateTime().getDayOfMonth() - agendaStartTime.getDayOfMonth();
        if (dayOffset < 0) {
            dayOffset = 6 - (agendaEndTime.getDayOfMonth() - appointment.getStartLocalDateTime().getDayOfMonth());
        }
        LocalDateTime start = getAppointmentStartTime(agendaStartTime.truncatedTo(ChronoUnit.DAYS), dayOffset,
                appointment);
        LocalDateTime end = getAppointmentEndTime(agendaStartTime.truncatedTo(ChronoUnit.DAYS), dayOffset, appointment);
        addToAgenda(appointment, start, end, endBoundary);
    }

    /** Computes and adds all occurrences of this yearly task to agenda. */
    private void addYearlyOccurrences(AppointmentImplLocal appointment, LocalDateTime endBoundary) {
        if (appointment.getStartLocalDateTime().getDayOfYear() > agendaStartTime.getDayOfYear() + 6
                || appointment.getStartLocalDateTime().getDayOfYear() < agendaStartTime.getDayOfYear()) {
            return;
        }
        int dayOffset = appointment.getStartLocalDateTime().getDayOfYear() - agendaStartTime.getDayOfYear();
        LocalDateTime start = getAppointmentStartTime(agendaStartTime, dayOffset, appointment);
        LocalDateTime end = getAppointmentEndTime(agendaStartTime, dayOffset, appointment);
        addToAgenda(appointment, start, end, endBoundary);
    }

    // ================Utility
    // methods================================================

    /** Returns a LocalDateTime object converted from TaskDate. */
    private LocalDateTime getConvertedTime(TaskDate t) {
        return LocalDateTime.ofInstant(new Date(t.getDateInLong()).toInstant(), ZoneId.systemDefault());
    }

    /** Returns the startTime of the agenda. */
    private LocalDateTime getAgendaStartDateTime() {
        LocalDateTime displayedDateTime = getDisplayedLocalDateTime().truncatedTo(ChronoUnit.DAYS);
        int dayOfWeek = displayedDateTime.getDayOfWeek().getValue() % 7;
        return displayedDateTime.minusDays(dayOfWeek);
    }

    /** Returns the endTime of the agenda. */
    private LocalDateTime getAgendaEndDateTime() {
        LocalDateTime displayedDateTime = getDisplayedLocalDateTime().truncatedTo(ChronoUnit.DAYS);
        int dayOfWeek = displayedDateTime.getDayOfWeek().getValue() % 7;
        return displayedDateTime.plusDays(6 - dayOfWeek);
    }

    /** Returns the startTime of the appointment. */
    private LocalDateTime getAppointmentStartTime(LocalDateTime startPoint, int dayOffset,
            AppointmentImplLocal source) {
        return startPoint.plusDays(dayOffset).plusHours(source.getStartLocalDateTime().getHour())
                .plusMinutes(source.getStartLocalDateTime().getMinute());
    }

    /** Returns the endTime of the appointment. */
    private LocalDateTime getAppointmentEndTime(LocalDateTime startPoint, int dayOffset, AppointmentImplLocal source) {
        return startPoint.plusDays(dayOffset).plusHours(source.getEndLocalDateTime().getHour())
                .plusMinutes(source.getEndLocalDateTime().getMinute());
    }

    /**
     * Returns a new appointment with start and end time specified and contains
     * same data with source.
     */
    private AppointmentImplLocal copyAppointment(AppointmentImplLocal src, LocalDateTime start, LocalDateTime end) {
        AppointmentImplLocal newOne = new AppointmentImplLocal().withAppointmentGroup(src.getAppointmentGroup())
                .withDescription(src.getDescription()).withSummary(src.getSummary());

        newOne.setStartLocalDateTime(start);
        newOne.setEndLocalDateTime(end);
        if (start.isAfter(src.getStartLocalDateTime()))
            newOne.setAppointmentGroup(new Agenda.AppointmentGroupImpl().withStyleClass("normal"));
        return newOne;
    }

    /** Adds a new appointment to agenda. */
    private void addToAgenda(AppointmentImplLocal appointment, LocalDateTime start, LocalDateTime end, LocalDateTime endBoundary) {
        AppointmentImplLocal newAppointment = copyAppointment(appointment, start, end);
        if (!appointments().contains(newAppointment) && !onSameDay(newAppointment, appointment) 
                && (endBoundary == null || !endBoundary.isBefore(newAppointment.getStartLocalDateTime())))
            appointments().add(newAppointment);
    }

    /**
     * Returns true if it is a future task that is not needed to add to agenda.
     */
    private boolean isOutsideAgenda(AppointmentImplLocal appointment) {
        return appointment.getStartLocalDateTime().truncatedTo(ChronoUnit.DAYS).isAfter(agendaEndTime);
    }

    /**
     * Returns true if it is a future task that is not needed to add to agenda.
     */
    private boolean isOutsideAgenda(TaskOccurrence taskOccurrence) {
        return getConvertedTime(taskOccurrence.getStartDate()).truncatedTo(ChronoUnit.DAYS).isAfter(agendaEndTime)
                || getConvertedTime(taskOccurrence.getEndDate()).truncatedTo(ChronoUnit.DAYS).isBefore(agendaStartTime);
    }

    /** Returns true if the appointments are on the same day. */
    private boolean onSameDay(AppointmentImplLocal src, AppointmentImplLocal toCheck) {
        return src.getStartLocalDateTime().truncatedTo(ChronoUnit.DAYS)
                .equals(toCheck.getStartLocalDateTime().truncatedTo(ChronoUnit.DAYS));
    }

}
```
###### \java\seedu\address\ui\NavbarPanel.java
``` java
    private void setEventHandlerForSelectionChangeEvent() {
        navbarView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                logger.fine("Selection in navigation bar panel changed to : '" + newValue + "'");
                raise(new NavigationSelectionChangedEvent(newValue));
            }
        });
    }
```
###### \java\seedu\address\ui\NavbarPanel.java
``` java
    public String getNavigationCommand(String navigation) {
        switch (navigation) {

        case NAVBAR_TODAY:
            command = FindCommand.COMMAND_WORD + " from 12am to tomorrow 12am";
            return command;
        case NAVBAR_DEADLINES:
            day = new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000);
            command = FindCommand.COMMAND_WORD + " by " + formatter.format(day) + " 12am";
            return command;
        case NAVBAR_INCOMING_DEADLINES:
            day = new Date(System.currentTimeMillis() + 24 * 8 * 60 * 60 * 1000);
            command = FindCommand.COMMAND_WORD + " by " + formatter.format(day) + " 12am";
            return command;
        case NAVBAR_FLOATING_TASKS:
            command = FindCommand.COMMAND_WORD + " -F";
            return command;
        case NAVBAR_COMPLETED:
            command = FindCommand.COMMAND_WORD + " -C";
            return command;
        default:
            return ListCommand.COMMAND_WORD;
        }
    }
```
###### \java\seedu\address\ui\TaskCard.java
``` java
    private void initializeDate() {
        if (dateComponent.getStartDate().getDateInLong() == TaskDate.DATE_NOT_PRESENT) {
            startDate.setText("");
        } else {
            startDate.setText(dateComponent.getStartDate().getFormattedDate());
        }

        if (dateComponent.getEndDate().getDateInLong() == TaskDate.DATE_NOT_PRESENT) {
            endDate.setText("");
        } else {
            endDate.setText(dateComponent.getEndDate().getFormattedDate());
        }
    }

    /**
     * Sets cell color for the task list. Style the css here to prevent
     * overriding.
     */
    private void setCellColor() {
        // normal non-floating task
        cardPane.setStyle("-fx-background-color : rgba(110, 196, 219, 0.3);");
        // Deadline
        if (dateComponent.hasOnlyEndDate())
            cardPane.setStyle("-fx-background-color : rgba(250, 124, 146, 0.3);");
        // Floating task
        if (task.getTaskType() == TaskType.FLOATING)
            cardPane.setStyle("-fx-background-color : rgba(255, 247, 192, 0.3);");
        // Blocked Slot
        if (task.getName().fullName.equals("BLOCKED SLOT"))
            cardPane.setStyle("-fx-background-color : rgba(148, 93, 96, 0.3);");
        // Completed
        if (dateComponent.isArchived()) {
            cardPane.setStyle("-fx-background-color : rgba(102,171,140,0.3);");
            name.setStyle("-fx-text-fill : derive(#373737, 20%);");
            id.setStyle("-fx-text-fill : derive(#373737, 20%);");
            startDate.setStyle("-fx-text-fill : derive(#373737, 20%);");
            endDate.setStyle("-fx-text-fill : derive(#373737, 20%);");
            recurringType.setStyle("-fx-text-fill : derive(#373737, 20%);");
        }
    }

```
###### \java\seedu\address\ui\UiManager.java
``` java
    @Subscribe
    private void handleNavigationSelectionChangedEvent(NavigationSelectionChangedEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getCommandBox().handleNavigationChanged(mainWindow.getNavbarPanel().getNavigationCommand(event.getNewSelection()));
    }
    
    @Subscribe
    private void handleTaskListChangedEvent(TaskListChangedEvent event){
    	logger.info(LogsCenter.getEventHandlingLogMessage(event));
    	mainWindow.getBrowserPanel().reloadAgenda(event.data.getTaskOccurrenceList());
    }
    
    @Subscribe
    private void handleAgendaTimeRangeChangedEvent(AgendaTimeRangeChangedEvent event){
    	logger.info(LogsCenter.getEventHandlingLogMessage(event));
    	mainWindow.getBrowserPanel().updateAgenda(event.getInputDate(), event.getData());
    }

}
```
###### \resources\view\BrowserPanel.fxml
``` fxml
<VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.BrowserPanel" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
	<children>
		<MyAgenda id="agenda" fx:id="agenda">
		</MyAgenda>
	</children>
</VBox>

```
###### \resources\view\MainWindow.fxml
``` fxml

<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="870.0" prefWidth="1545.0" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.MainWindow">
   <stylesheets>     
      <URL value="@Extensions.css" />
   </stylesheets>
   <children>
      <MenuBar VBox.vgrow="NEVER">
         <menus>
            <Menu mnemonicParsing="false" text="File">
               <items>
                  <MenuItem mnemonicParsing="false" onAction="#handleExit" text="Exit" />
               </items>
            </Menu>
            <Menu mnemonicParsing="false" text="Help">
               <items>
                  <MenuItem fx:id="helpMenuItem" mnemonicParsing="false" onAction="#handleHelp" text="Help" />
               </items>
            </Menu>
         </menus>
      </MenuBar>
      <SplitPane id="splitPane" fx:id="splitPane" dividerPositions="0.4" VBox.vgrow="ALWAYS">
      	<items>
      		<VBox fx:id="navbar" minWidth="300" prefHeight="750.0" prefWidth="330.0">
         		<padding>
         			<Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
         		</padding>
         		<children>
         			<AnchorPane fx:id="navbarPanelPlaceholder" VBox.vgrow="ALWAYS" />
         		</children>
      		</VBox>
      		<AnchorPane minWidth="1200.0">
         <children>
         			<AnchorPane fx:id="commandBoxPlaceholder" minHeight="60.0" minWidth="1200.0" prefHeight="60.0" prefWidth="1200.0" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
            			<padding>
               			<Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
            			</padding>
         			</AnchorPane>
         			<AnchorPane fx:id="resultDisplayPlaceholder" layoutY="60.0" maxHeight="90.0" minHeight="90.0" minWidth="1200.0" prefHeight="90.0" prefWidth="1200.0" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
           				<padding>
               				<Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
           				</padding>
       				</AnchorPane>
         			<SplitPane id="splitPane" fx:id="splitPane" dividerPositions="0.3" layoutY="170.0" minHeight="570.0" prefHeight="570.0" prefWidth="1200.0" VBox.vgrow="ALWAYS">
            			<items>
               			<VBox fx:id="taskList" minWidth="100" prefHeight="570.0" prefWidth="430">
                   			<padding>
                       			<Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                   			</padding>
                  				<children>
                     				<AnchorPane fx:id="taskListPanelPlaceholder" VBox.vgrow="ALWAYS" />
                  				</children>
               			</VBox>
               			<AnchorPane fx:id="browserPlaceholder" maxWidth="Infinity" minWidth="100" prefHeight="570.0" prefWidth="760.0">
                   			<padding>
                       			<Insets bottom="10" left="10" right="10" top="10" />
                   			</padding>
               			</AnchorPane>
            			</items>
         			</SplitPane>
         </children>
      		</AnchorPane>
      	</items>
      	</SplitPane>
      	
      	<AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="NEVER" />
   </children>
</VBox>
```
###### \resources\view\NavbarCard.fxml
``` fxml
<HBox id="cardPaneNav" fx:id="cardPaneNav" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane id="navBarGrid" prefHeight="71.0" prefWidth="250.0" HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints hgrow="SOMETIMES" maxWidth="250.0" minWidth="10.0" prefWidth="250.0" />
                <ColumnConstraints hgrow="SOMETIMES" maxWidth="150.0" minWidth="0.0" prefWidth="0.0" />
            </columnConstraints>
            <children>
                <VBox alignment="CENTER_LEFT" maxHeight="150.0" minHeight="53.0" prefHeight="73.0" prefWidth="250.0" GridPane.columnIndex="0">
                    <stylesheets>
                        <URL value="@DarkTheme.css" />
                        <URL value="@Extensions.css" />
                    </stylesheets>
                    <padding>
                        <Insets bottom="5" left="15" right="5" top="5" />
                    </padding>

                    <children>
                        <HBox alignment="CENTER" prefHeight="27.0" prefWidth="245.0" spacing="5">
                            <children>
                                <HBox alignment="CENTER" minWidth="150.0" prefHeight="27.0" prefWidth="211.0" scaleShape="false">
                                   <children>
                                   <VBox alignment="CENTER_LEFT">
                                      <children>
                                 <ImageView fitHeight="30.0" fitWidth="30.0" pickOnBounds="true" preserveRatio="true">
                                    <image>
                                    
                                 </image>
                                 </ImageView>
                                      </children>
                           </VBox>
                                       <Label fx:id="navname" styleClass="cell_big_label" text="\$first" textAlignment="CENTER">
                                 		</Label>
                                   </children>
                                </HBox>
                            </children>
                        </HBox>
                    </children>
                </VBox>
            </children>
         <rowConstraints>
            <RowConstraints />
         </rowConstraints>
        </GridPane>
    </children>
</HBox>
```
